GUIÓN COMPLETO PARA EXPOSICIÓN: PATRÓN SINGLETON
==============================================
Universidad Autónoma de Occidente - Ingeniería de Software 2
Duración: 45 minutos | Septiembre 2025
==============================================

INTRODUCCIÓN [2 minutos]
========================

Buenos días. Hoy exploraremos el patrón Singleton, uno de los patrones más conocidos pero también más debatidos en la ingeniería de software. Veremos 6 implementaciones diferentes, desde la más simple hasta la más robusta, con ejemplos prácticos de sistemas empresariales.

Durante los próximos 45 minutos cubriremos:
- Conceptos fundamentales del patrón
- 6 implementaciones con sus trade-offs
- Casos reales en sistemas enterprise
- Alternativas modernas y mejores prácticas

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 1: INTRODUCCIÓN AL PATRÓN SINGLETON [4 minutos]
==========================================================

[MOSTRAR DIAPOSITIVA 1 - Conceptos fundamentales]

**[EXPLICAR DEFINICIÓN]**
El patrón Singleton es un patrón creacional que resuelve un problema específico: garantizar que una clase tenga exactamente UNA instancia y proporcionar acceso global controlado a ella.

**[DETALLE DE GARANTÍAS]**
¿Qué significa "una sola instancia"? Significa que sin importar cuántas veces llamemos al constructor o método de acceso, siempre obtendremos LA MISMA instancia en memoria. Es como tener un único gerente general en una empresa - solo puede haber uno.

**[EXPLICAR ACCESO GLOBAL]**
El acceso global controlado significa que cualquier parte de nuestro código puede acceder a esta instancia, pero de manera controlada - no a través de una variable global caótica, sino mediante un método bien definido.

**[LAZY INITIALIZATION]**
La inicialización perezosa o "lazy initialization" es crear el objeto solo cuando realmente se necesita. Es como no contratar un empleado hasta que realmente tengamos trabajo para él.

**[EJEMPLO PRÁCTICO DETALLADO]**
Veamos el ejemplo de ConfigurationManager. Sin Singleton:
```java
// ❌ Problemático - múltiples configuraciones
ConfigurationManager config1 = new ConfigurationManager(); // Lee archivo config.properties
ConfigurationManager config2 = new ConfigurationManager(); // Lee archivo OTRA VEZ
```
Cada instancia leería el archivo de configuración, desperdiciaría memoria y podría tener valores inconsistentes si el archivo cambia.

Con Singleton:
```java
// ✅ Eficiente - una sola configuración
ConfigurationManager config1 = ConfigurationManager.getInstance();
ConfigurationManager config2 = ConfigurationManager.getInstance();
// config1 == config2 (misma referencia en memoria)
```

**[CUÁNDO USAR - CRITERIOS ESPECÍFICOS]**
El Singleton es apropiado cuando:
1. Necesitas exactamente UNA instancia - no cero, no dos, UNA
2. Esta instancia debe ser accesible globalmente
3. La instancia controla acceso a un recurso compartido

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 2: CUÁNDO USAR SINGLETON [3 minutos]
===============================================

[MOSTRAR DIAPOSITIVA 2 - Casos de uso y framework de decisión]

**[CASOS DE USO DETALLADOS]**
Permítanme explicar cada caso con ejemplos concretos de sistemas empresariales:

**Configuración Global:**
En un sistema bancario, necesitamos configurar URLs de APIs, timeouts, credenciales. Una sola instancia garantiza consistencia:
```java
String apiUrl = ConfigManager.getInstance().getProperty("api.payments.url");
int timeout = ConfigManager.getInstance().getIntProperty("api.timeout", 30000);
```

**Pool de Conexiones:**
Las conexiones a base de datos son costosas de crear. Un pool centralizado las reutiliza eficientemente:
```java
Connection conn = ConnectionPool.getInstance().getConnection();
// Usa la conexión
ConnectionPool.getInstance().releaseConnection(conn);
```

**Logging Centralizado:**
Un solo logger evita conflictos de escritura y garantiza formato consistente:
```java
Logger.getInstance().info("User " + userId + " login successful");
Logger.getInstance().error("Payment failed for transaction " + txId);
```

**Cache Manager:**
Una cache centralizada evita duplicación de datos y optimiza memoria:
```java
UserData user = CacheManager.getInstance().get("user:" + userId);
if (user == null) {
    user = database.getUser(userId);
    CacheManager.getInstance().put("user:" + userId, user);
}
```

**[FRAMEWORK DE DECISIÓN]**
Antes de implementar Singleton, pregúntate:
- ¿Realmente necesito exactamente UNA instancia?
- ¿Es esta instancia un recurso compartido?
- ¿El acceso global está justificado?
- ¿Podría usar dependency injection en su lugar?

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 3: EAGER INITIALIZATION [4 minutos]
===============================================

[MOSTRAR DIAPOSITIVA 3 - Eager Initialization]

**[EXPLICAR EL CONCEPTO]**
Eager Initialization significa que la instancia se crea INMEDIATAMENTE cuando la JVM carga la clase, no cuando se llama getInstance() por primera vez.

**[ANÁLISIS LÍNEA POR LÍNEA DEL CÓDIGO]**
Veamos cada parte del código:

```java
private static final DatabaseManager INSTANCE = new DatabaseManager();
```
- `static`: Pertenece a la clase, no a una instancia específica
- `final`: Una vez asignada, no puede cambiar la referencia
- `= new DatabaseManager()`: Se ejecuta cuando la JVM carga la clase

```java
private DatabaseManager() {
    // Constructor privado - CRÍTICO
}
```
El constructor privado es FUNDAMENTAL. Impide que código externo haga `new DatabaseManager()`, garantizando que solo existe la instancia controlada.

```java
public static DatabaseManager getInstance() {
    return INSTANCE;  // Solo retorna la referencia
}
```
Este método es extremadamente rápido - simplemente retorna una referencia existente, sin verificaciones ni creación.

**[FLUJO DE EJECUCIÓN DETALLADO]**
1. **Carga de clase**: Cuando la JVM encuentra la primera referencia a DatabaseManager
2. **Instancia creada**: Se ejecuta `new DatabaseManager()` automáticamente
3. **getInstance()**: Simplemente retorna la referencia ya existente
4. **Accesos posteriores**: Todos retornan la misma referencia, instantáneamente

**[THREAD-SAFETY AUTOMÁTICO]**
¿Por qué es thread-safe? Porque la JVM garantiza que la inicialización de campos `static final` ocurre de manera atómica. Es imposible que dos threads vean estados inconsistentes.

**[VENTAJAS ESPECÍFICAS]**
✅ **Simplicidad extrema**: El código es muy fácil de entender
✅ **Performance de acceso**: getInstance() es prácticamente instantáneo
✅ **Thread-safety garantizado**: Sin necesidad de sincronización

**[DESVENTAJAS ESPECÍFICAS]**
❌ **Desperdicio de memoria**: Si nunca usas la instancia, ya está creada
❌ **Impacto en startup**: Si el constructor es costoso, afecta el tiempo de inicio
❌ **Manejo de excepciones**: Si falla el constructor, la clase no se puede cargar

**[CUÁNDO ES IDEAL]**
- Constructor simple y rápido
- Sabes que SIEMPRE necesitarás la instancia
- La aplicación tiene recursos abundantes
- El tiempo de startup no es crítico

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 4: LAZY INITIALIZATION [4 minutos]
==============================================

[MOSTRAR DIAPOSITIVA 4 - Lazy Initialization]

**[CONCEPTO FUNDAMENTAL]**
Lazy Initialization es lo opuesto a Eager - la instancia se crea solo cuando se llama getInstance() por primera vez. Es la implementación más intuitiva del patrón.

**[ANÁLISIS DEL CÓDIGO]**
```java
private static DatabaseConnectionPool instance;  // Inicialmente null
```
La variable instance inicia como null - no hay objeto creado aún.

```java
if (instance == null) {  // Primera verificación
    instance = new DatabaseConnectionPool();  // Creación costosa
}
return instance;
```

**[FLUJO DE EJECUCIÓN PASO A PASO]**
1. **Primera llamada**: instance es null → se crea el objeto → se retorna
2. **Llamadas posteriores**: instance no es null → se retorna directamente

**[EL PROBLEMA DE CONCURRENCIA]**
Aquí está el gran problema. Imaginen este escenario:

```
Tiempo 1: Thread A llama getInstance()
Tiempo 2: Thread A evalúa (instance == null) → TRUE
Tiempo 3: Thread B llama getInstance()  
Tiempo 4: Thread B evalúa (instance == null) → TRUE (¡aún!)
Tiempo 5: Thread A ejecuta new DatabaseConnectionPool() → Instancia A
Tiempo 6: Thread B ejecuta new DatabaseConnectionPool() → Instancia B ❌
```

¡Tenemos DOS instancias! El patrón Singleton está roto.

**[RACE CONDITION EXPLICADA]**
Una race condition ocurre cuando múltiples threads acceden y modifican datos compartidos, y el resultado depende del timing. En este caso, ambos threads "ganan la carrera" de crear la instancia.

**[CUÁNDO ES APROPIADO]**
Lazy initialization sin sincronización solo es seguro en aplicaciones single-thread:
- Scripts simples
- Aplicaciones de escritorio con un solo thread
- Prototipos y demos

**[VENTAJAS]**
✅ **Eficiencia de memoria**: Solo usa memoria cuando necesita el objeto
✅ **Startup rápido**: No impacta el tiempo de inicio de la aplicación
✅ **Simplicidad**: Código fácil de entender

**[DESVENTAJAS CRÍTICAS]**
❌ **NO thread-safe**: Puede crear múltiples instancias
❌ **Impredecible**: El comportamiento cambia según el timing
❌ **Bugs silenciosos**: Puede funcionar en desarrollo pero fallar en producción

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 5: SYNCHRONIZED METHOD [4 minutos]
==============================================

[MOSTRAR DIAPOSITIVA 5 - Synchronized Method]

**[LA SOLUCIÓN OBVIA AL PROBLEMA]**
Si Lazy Initialization tiene problemas de concurrencia, la solución más directa es sincronizar todo el método getInstance().

**[ANÁLISIS DEL CÓDIGO]**
```java
public static synchronized SecurityManager getInstance() {
    if (instance == null) {
        instance = new SecurityManager();
    }
    return instance;
}
```
La palabra clave `synchronized` garantiza que solo UN thread puede ejecutar este método a la vez.

**[CÓMO FUNCIONA LA SINCRONIZACIÓN]**
Cuando un thread llama a getInstance():
1. **Obtiene el lock**: Solo este thread puede continuar
2. **Ejecuta el código**: Verifica, crea si necesario, retorna
3. **Libera el lock**: Otros threads pueden proceder

**[FLUJO CON MÚLTIPLES THREADS]**
```
Thread A: Obtiene lock → verifica null → crea instancia → libera lock
Thread B: Espera lock → obtiene lock → verifica NOT null → retorna → libera lock
Thread C: Espera lock → obtiene lock → verifica NOT null → retorna → libera lock
```

**[EL PROBLEMA DE PERFORMANCE]**
Aquí está el gran problema: la sincronización es necesaria solo DURANTE LA CREACIÓN. Una vez creada la instancia, cada acceso posterior aún requiere obtener y liberar el lock innecesariamente.

**[EJEMPLO DE DESPERDICIO]**
```java
// PRIMERA llamada: Lock necesario ✅
SecurityManager sm1 = SecurityManager.getInstance(); // 100 microsegundos

// SIGUIENTES 10,000 llamadas: Lock innecesario ❌
for (int i = 0; i < 10000; i++) {
    SecurityManager sm = SecurityManager.getInstance(); // 50 microsegundos c/u
}
```
El overhead se acumula significativamente en aplicaciones de alto tráfico.

**[IMPACTO EN ESCALABILIDAD]**
En un sistema web con 1000 requests/segundo:
- Sin sincronización: getInstance() toma ~1 microsegundo
- Con sincronización: getInstance() toma ~50 microsegundos
- Impacto total: 49,000 microsegundos extra por segundo = 5% de CPU desperdiciada

**[CUÁNDO ES ACEPTABLE]**
- Aplicaciones con pocas llamadas a getInstance()
- Sistemas donde la simplicidad es más importante que performance
- Prototipos donde el rendimiento no es crítico

**[CARACTERÍSTICAS CLAVE]**
✅ **Thread-safe**: Sin race conditions
✅ **Simple**: Fácil de implementar y entender
✅ **Lazy**: Creación bajo demanda
❌ **Performance**: Overhead en cada acceso
❌ **Escalabilidad**: Cuello de botella en alta concurrencia

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 6: DOUBLE-CHECKED LOCKING [5 minutos]
=================================================

[MOSTRAR DIAPOSITIVA 6 - Double-Checked Locking]

**[LA OPTIMIZACIÓN INTELIGENTE]**
Double-Checked Locking optimiza el Synchronized Method eliminando la sincronización innecesaria después de la creación. Es una técnica elegante pero compleja.

**[ANÁLISIS DETALLADO DEL CÓDIGO]**
```java
private static volatile CacheManager instance;  // ⚠️ VOLATILE es crítico
```
`volatile` garantiza que todos los threads vean el mismo valor de instance. Sin volatile, el patrón está ROTO.

```java
public static CacheManager getInstance() {
    if (instance == null) {  // 🔍 PRIMERA verificación (sin lock)
        synchronized (CacheManager.class) {  // 🔐 Obtener lock
            if (instance == null) {  // 🔍 SEGUNDA verificación (con lock)
                instance = new CacheManager();
            }
        }
    }
    return instance;
}
```

**[¿POR QUÉ DOS VERIFICACIONES?]**
Imaginemos qué pasaría con una sola verificación:

```java
// ❌ INCORRECTO - una sola verificación
if (instance == null) {
    synchronized (CacheManager.class) {
        instance = new CacheManager();  // ¡Sobrescribe instancia existente!
    }
}
```

Con una verificación:
1. Thread A pasa la verificación (instance == null)
2. Thread B pasa la verificación (instance == null)  
3. Thread A obtiene lock, crea instancia
4. Thread B obtiene lock, ¡SOBRESCRIBE la instancia!

**[FLUJO CON DOS VERIFICACIONES]**
Escenario exitoso:
```
Thread A: (instance == null) → true → obtiene lock → (instance == null) → true → crea
Thread B: (instance == null) → true → espera lock → obtiene lock → (instance == null) → FALSE → sale
```

Escenario de acceso normal:
```
Thread C: (instance == null) → FALSE → retorna inmediatamente (¡sin lock!)
```

**[LA IMPORTANCIA CRÍTICA DE VOLATILE]**
Sin `volatile`, pueden ocurrir reordenamientos de instrucciones:

```java
// El compilador podría reordenar:
instance = new CacheManager();
// Como:
1. instance = allocate_memory();  // instance no es null pero objeto no está construido
2. construct_CacheManager();     // construir objeto
3. // Otro thread ve instance != null pero objeto no está listo ❌
```

`volatile` previene este reordenamiento y garantiza visibilidad entre threads.

**[VENTAJAS Y TRADE-OFFS]**
✅ **Performance optimizada**: Lock solo durante creación
✅ **Thread-safe**: Con volatile, es completamente seguro
✅ **Lazy loading**: Creación bajo demanda

❌ **Complejidad**: Fácil de implementar incorrectamente
❌ **Dependencia de volatile**: Requiere comprensión profunda del memory model
❌ **Debugging**: Más difícil de debuggear problemas

**[CUÁNDO USARLO]**
- Performance crítico con acceso frecuente
- Sistemas de alto tráfico
- Cuando realmente entiendes volatile y memory models
- Equipos de desarrollo experimentados

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 7: BILL PUGH PATTERN [5 minutos]
===========================================

[MOSTRAR DIAPOSITIVA 7 - Bill Pugh Pattern]

**[LA SOLUCIÓN ELEGANTE]**
El Bill Pugh Pattern, también conocido como "Initialization-on-demand holder idiom", es considerado la MEJOR implementación de Singleton para la mayoría de casos. Combina lazy loading, thread-safety y performance sin complejidad.

**[ANÁLISIS ARQUITECTURAL DEL CÓDIGO]**
```java
public class LogManager {
    private LogManager() {
        // Constructor privado como siempre
    }
    
    // 🏗️ La clase interna estática es la CLAVE
    private static class LogManagerHolder {
        private static final LogManager INSTANCE = new LogManager();
    }
    
    public static LogManager getInstance() {
        return LogManagerHolder.INSTANCE;  // Acceso a la clase interna
    }
}
```

**[LA GENIALIDAD DEL DISEÑO]**
La brillantez está en la clase interna estática `LogManagerHolder`. Esta clase:
1. **No se carga hasta que se accede**: La JVM no carga clases internas estáticas hasta que se referencian
2. **Garantiza thread-safety**: La JVM maneja la inicialización de campos static final de manera thread-safe
3. **Proporciona lazy loading**: INSTANCE se crea solo cuando se llama getInstance()

**[FLUJO DE EJECUCIÓN DETALLADO]**
1. **Primera llamada a getInstance()**:
   - JVM necesita acceder a LogManagerHolder.INSTANCE
   - JVM carga la clase LogManagerHolder
   - JVM inicializa INSTANCE = new LogManager()
   - Se retorna la instancia

2. **Llamadas posteriores**:
   - LogManagerHolder ya está cargada
   - INSTANCE ya existe
   - Se retorna inmediatamente

**[¿POR QUÉ ES THREAD-SAFE?]**
La JVM garantiza que la inicialización de clases es thread-safe. Según la especificación de Java:
- Solo un thread puede inicializar una clase
- Otros threads esperan hasta que la inicialización termine
- Una vez inicializada, todos los threads ven el estado final

Es como tener un lock automático manejado por la JVM, pero sin el overhead de sincronización en accesos posteriores.

**[COMPARACIÓN CON OTRAS IMPLEMENTACIONES]**

Vs. Eager Initialization:
- ✅ Lazy loading real
- ✅ Mismo performance después de creación
- ✅ Misma simplicidad

Vs. Synchronized Method:
- ✅ Sin overhead de sincronización
- ✅ Mejor performance en alta concurrencia
- ✅ Thread-safe garantizado

Vs. Double-Checked Locking:
- ✅ Sin necesidad de volatile
- ✅ Código más simple y menos propenso a errores
- ✅ Mismo performance

**[VENTAJAS COMPLETAS]**
✅ **Thread-safe perfecto**: Garantizado por la JVM
✅ **Lazy loading verdadero**: Carga solo cuando se necesita
✅ **Performance óptimo**: Sin overhead después de creación
✅ **Simplicidad**: Código limpio y fácil de entender
✅ **Robustez**: Difícil de implementar incorrectamente

**[MÍNIMAS DESVENTAJAS]**
❌ **Complejidad conceptual**: Requiere entender class loading
❌ **Debugging**: La clase interna puede confundir en stack traces
❌ **Incompatibilidad**: Muy raros casos con class loaders exóticos

**[CUÁNDO ES LA MEJOR OPCIÓN]**
- La mayoría de aplicaciones enterprise
- Cuando necesitas el mejor balance de características
- Equipos que valoran código limpio y mantenible
- Sistemas de producción donde la robustez es crítica

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 8: ENUM SINGLETON [4 minutos]
=========================================

[MOSTRAR DIAPOSITIVA 8 - Enum Singleton]

**[LA RECOMENDACIÓN DE JOSHUA BLOCH]**
Joshua Bloch, creador de muchas APIs de Java y autor de "Effective Java", recomienda usar Enum como la implementación más robusta de Singleton. Dice textualmente: "A single-element enum type is often the best way to implement a singleton."

**[ANÁLISIS DEL CÓDIGO]**
```java
public enum SessionManager {
    INSTANCE;  // ⭐ Este es nuestro Singleton
    
    private UserSession currentSession;
    
    public void startSession(User user) {
        currentSession = new UserSession(user);
    }
    
    public UserSession getCurrentSession() {
        return currentSession;
    }
}
```

**[¿CÓMO FUNCIONA UN ENUM COMO SINGLETON?]**
Los enums en Java tienen propiedades especiales:
1. **Instancia única garantizada**: La JVM garantiza que solo existe UNA instancia de cada valor del enum
2. **Thread-safety automático**: La inicialización de enums es thread-safe por defecto
3. **Serialización segura**: Los enums se serializan de manera especial, preservando la unicidad

**[USO SÚPER SIMPLE]**
```java
// Acceso directo al singleton
SessionManager.INSTANCE.startSession(user);
UserSession session = SessionManager.INSTANCE.getCurrentSession();
SessionManager.INSTANCE.endSession();

// También se puede asignar a variable si se prefiere
SessionManager manager = SessionManager.INSTANCE;
manager.startSession(user);
```

**[PROTECCIONES AUTOMÁTICAS EXTRAORDINARIAS]**

**1. Protección contra Reflection:**
```java
// ❌ Esto fallará con IllegalArgumentException
Constructor<SessionManager> constructor = SessionManager.class.getDeclaredConstructor();
constructor.setAccessible(true);
SessionManager fake = constructor.newInstance(); // ¡EXCEPTION!
```

**2. Protección contra Serialización:**
```java
// Serialización y deserialización mantienen la misma instancia
SessionManager original = SessionManager.INSTANCE;
// ... serializar y deserializar ...
SessionManager deserialized = // ... de archivo ...
assert original == deserialized; // ✅ TRUE
```

**3. Protección contra Clonación:**
Los enums no pueden ser clonados. `clone()` automáticamente lanza `CloneNotSupportedException`.

**[COMPARACIÓN DE ROBUSTEZ]**

Implementación tradicional vulnerable:
```java
public class TraditionalSingleton {
    private static TraditionalSingleton instance;
    
    // ❌ Vulnerable a reflection
    private TraditionalSingleton() {}
    
    // ❌ Serialización puede crear nueva instancia
    // ❌ Clonación puede crear nueva instancia
}
```

Enum Singleton invulnerable:
```java
public enum BulletproofSingleton {
    INSTANCE;
    // ✅ Inmune a reflection
    // ✅ Serialización segura automática
    // ✅ Clonación imposible
}
```

**[VENTAJAS ÚNICAS]**
✅ **Máxima robustez**: Resistente a múltiples vectores de ataque
✅ **Concisión extrema**: Mínimo código necesario
✅ **Performance**: Tan rápido como implementaciones tradicionales
✅ **Thread-safety**: Automático sin configuración

**[LIMITACIONES]**
❌ **Herencia imposible**: Los enums no pueden extender clases
❌ **Confusión inicial**: Puede ser confuso para desarrolladores nuevos
❌ **Inflexibilidad**: No permite lazy loading controlado
❌ **Deserialización**: Comportamiento especial puede sorprender

**[CUÁNDO USAR ENUM SINGLETON]**
- Sistemas críticos donde la seguridad es paramount
- Aplicaciones que manejan serialización frecuente
- Cuando quieres máxima robustez con mínimo código
- Sistemas que pueden ser objetivo de ataques de reflection

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 9: COMPARACIÓN DE IMPLEMENTACIONES [4 minutos]
==========================================================

[MOSTRAR DIAPOSITIVA 9 - Tabla comparativa]

**[ANÁLISIS SISTEMÁTICO]**
Ahora que hemos visto todas las implementaciones, analicemos sistemáticamente cuándo usar cada una.

**[EAGER INITIALIZATION - Análisis]**
✅ **Thread-Safe**: ⭐⭐⭐ Garantizado por JVM
✅ **Performance**: ⭐⭐⭐ Acceso instantáneo
❌ **Lazy Load**: ❌ Se crea aunque no se use
✅ **Complejidad**: ⭐ Muy simple
**Recomendación**: Objetos livianos que siempre se usan

**[LAZY SIMPLE - Análisis]**
❌ **Thread-Safe**: ❌ Race conditions posibles
✅ **Performance**: ⭐⭐⭐ Rápido cuando funciona
✅ **Lazy Load**: ✅ Verdadero lazy loading
✅ **Complejidad**: ⭐ Muy simple
**Recomendación**: Solo aplicaciones single-thread

**[SYNCHRONIZED METHOD - Análisis]**
✅ **Thread-Safe**: ⭐⭐⭐ Completamente seguro
❌ **Performance**: ⭐ Overhead en cada acceso
✅ **Lazy Load**: ✅ Creación bajo demanda
✅ **Complejidad**: ⭐⭐ Relativamente simple
**Recomendación**: Evitar - performance pobre

**[DOUBLE-CHECKED LOCKING - Análisis]**
✅ **Thread-Safe**: ⭐⭐⭐ Con volatile correcto
✅ **Performance**: ⭐⭐ Bueno después de creación
✅ **Lazy Load**: ✅ Lazy loading eficiente
❌ **Complejidad**: ⭐⭐⭐ Fácil de implementar mal
**Recomendación**: Solo para expertos

**[BILL PUGH PATTERN - Análisis]**
✅ **Thread-Safe**: ⭐⭐⭐ Garantizado por JVM
✅ **Performance**: ⭐⭐⭐ Óptimo en todos los aspectos
✅ **Lazy Load**: ✅ Lazy loading elegante
✅ **Complejidad**: ⭐⭐ Moderado pero robusto
**Recomendación**: ⭐ PRIMERA OPCIÓN para la mayoría

**[ENUM SINGLETON - Análisis]**
✅ **Thread-Safe**: ⭐⭐⭐ Automático
✅ **Performance**: ⭐⭐⭐ Excelente
❌ **Lazy Load**: ❌ Eager por naturaleza
✅ **Complejidad**: ⭐ Muy simple
**Recomendación**: Máxima seguridad requerida

**[GUÍA DE DECISIÓN PRÁCTICA]**

**Para desarrollo nuevo:**
1. **Primera opción**: Bill Pugh Pattern
2. **Si necesitas máxima seguridad**: Enum Singleton
3. **Si el objeto es liviano**: Eager Initialization

**Para sistemas legacy:**
1. **Si ya tienes Synchronized**: Migra a Bill Pugh
2. **Si tienes Double-Checked**: Revisa implementación o migra
3. **Si tienes Lazy Simple**: Urgente migrar a thread-safe

**Para casos específicos:**
- **Configuración del sistema**: Bill Pugh
- **Gestión de sesiones críticas**: Enum
- **Logger simple**: Eager
- **Cache manager**: Bill Pugh
- **Pool de conexiones**: Bill Pugh

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 10: PROBLEMAS Y ALTERNATIVAS [5 minutos]
====================================================

[MOSTRAR DIAPOSITIVA 10 - Críticas y alternativas modernas]

**[LA CONTROVERSIA DEL SINGLETON]**
El patrón Singleton es uno de los más criticados en el desarrollo moderno. Entendamos por qué y qué alternativas tenemos.

**[PROBLEMAS FUNDAMENTALES]**

**1. Dificultad en Testing:**
```java
// ❌ Difícil de testear
public class OrderService {
    public void processOrder(Order order) {
        Logger.getInstance().log("Processing: " + order.getId());
        // ¿Cómo mockear Logger para testing?
    }
}

// Problema: No puedes inyectar un mock
// La dependencia está hardcodeada
```

**2. Violación de Principios SOLID:**

**Single Responsibility Principle (SRP):**
```java
// ❌ Múltiples responsabilidades
public class DatabaseManager {
    // Responsabilidad 1: Ser singleton
    private static DatabaseManager instance;
    public static DatabaseManager getInstance() { ... }
    
    // Responsabilidad 2: Gestionar base de datos
    public void executeQuery(String sql) { ... }
    public Connection getConnection() { ... }
}
```

**Dependency Inversion Principle (DIP):**
```java
// ❌ Depende de concreciones, no abstracciones
public class UserService {
    public void saveUser(User user) {
        DatabaseManager.getInstance().save(user); // Dependencia concreta
    }
}
```

**3. Estado Global Problemático:**
```java
// ❌ Estado compartido y mutable
public enum SessionManager {
    INSTANCE;
    
    private UserSession currentSession; // ¡Estado global!
    
    public void setCurrentSession(UserSession session) {
        this.currentSession = session; // Modifica estado global
    }
}

// Problema: Múltiples threads pueden corromper el estado
```

**4. Acoplamiento Fuerte:**
```java
// ❌ Fuertemente acoplado
public class PaymentService {
    public void processPayment() {
        Logger.getInstance().log("Payment started");
        DatabaseManager.getInstance().save(...);
        NotificationService.getInstance().send(...);
        // Acoplado a 3 singletons - difícil de cambiar
    }
}
```

**[ALTERNATIVAS MODERNAS]**

**1. Dependency Injection - La Mejor Alternativa:**
```java
// ✅ Con Dependency Injection
public class OrderService {
    private final Logger logger;
    private final PaymentGateway gateway;
    
    // Dependencias inyectadas en constructor
    public OrderService(Logger logger, PaymentGateway gateway) {
        this.logger = logger;
        this.gateway = gateway;
    }
    
    public void processOrder(Order order) {
        logger.log("Processing: " + order.getId());
        gateway.charge(order.getAmount());
    }
}

// Testing es trivial:
@Test
public void testProcessOrder() {
    Logger mockLogger = mock(Logger.class);
    PaymentGateway mockGateway = mock(PaymentGateway.class);
    
    OrderService service = new OrderService(mockLogger, mockGateway);
    // ... test with mocks
}
```

**2. Framework DI - Spring Example:**
```java
@Service
public class OrderService {
    @Autowired
    private Logger logger;
    
    @Autowired  
    private PaymentGateway gateway;
    
    // Spring maneja el lifecycle como singleton si quieres
}

@Configuration
public class AppConfig {
    @Bean
    @Scope("singleton")  // Singleton controlado por Spring
    public Logger logger() {
        return new Logger();
    }
}
```

**3. Factory Pattern:**
```java
// ✅ Factory para control centralizado
public class ServiceFactory {
    private static Logger logger;
    
    public static Logger getLogger() {
        if (logger == null) {
            logger = new Logger();
        }
        return logger;
    }
    
    // Permite diferentes implementaciones
    public static Logger getLogger(LogLevel level) {
        return new Logger(level);
    }
}
```

**[CUÁNDO EVITAR SINGLETON]**
❌ **Testing es crítico**: Unit testing frecuente
❌ **Arquitectura flexible**: Necesitas cambiar implementaciones
❌ **Microservicios**: Estado distribuido
❌ **Frameworks DI disponibles**: Spring, CDI, Guice

**[CUÁNDO SINGLETON AÚN ES VÁLIDO]**
✅ **Configuración estática**: Properties que no cambian
✅ **Utilidades sin estado**: Math helpers, formatters
✅ **Performance crítico**: Overhead de DI no aceptable
✅ **Aplicaciones legacy**: Sin framework DI disponible

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 11: CASOS REALES EMPRESARIALES [4 minutos]
======================================================

[MOSTRAR DIAPOSITIVA 11 - Implementaciones enterprise]

**[CASOS REALES EN SISTEMAS EMPRESARIALES]**
Veamos implementaciones reales donde Singleton aporta valor en sistemas enterprise.

**[CASO 1: LEGACY SYSTEM ADAPTER - Explicación Detallada]**
```java
public class MainframeAdapter {
    private static volatile MainframeAdapter instance;
    
    private MainframeConnection connection;
    private ProtocolConverter converter;
    
    private MainframeAdapter() {
        // Conexión costosa al mainframe - puede tomar 5-10 segundos
        this.connection = new MainframeConnection("tcp://mainframe.company.com:3270");
        this.converter = new ProtocolConverter();
        
        // Autenticación con sistema legacy
        connection.authenticate("ENTERPRISE_USER", "SYSTEM_PASSWORD");
        
        // Configuración de pooling de conexiones internas
        connection.configurePool(minConnections: 5, maxConnections: 20);
    }
    
    public static MainframeAdapter getInstance() {
        if (instance == null) {
            synchronized (MainframeAdapter.class) {
                if (instance == null) {
                    instance = new MainframeAdapter();
                }
            }
        }
        return instance;
    }
    
    public CustomerData queryCustomer(String customerId) {
        // Convierte request moderno a protocolo mainframe
        MainframeRequest request = converter.toMainframeFormat(customerId);
        
        // Ejecuta query en sistema legacy
        MainframeResponse response = connection.execute(request);
        
        // Convierte respuesta legacy a formato moderno
        return converter.toModernFormat(response);
    }
}
```

**¿Por qué Singleton aquí?**
- La conexión al mainframe es EXTREMADAMENTE costosa
- Necesitamos una sola pool de conexiones
- El adapter es stateless - solo convierte protocolos
- Se usa desde múltiples microservicios

**[CASO 2: CIRCUIT BREAKER PATTERN - Enterprise Resilience]**
```java
public enum CircuitBreakerManager {
    INSTANCE;
    
    private final Map<String, CircuitBreaker> breakers = new ConcurrentHashMap<>();
    private final ScheduledExecutorService healthChecker = Executors.newScheduledThreadPool(5);
    
    CircuitBreakerManager() {
        // Inicia health checking automático cada 30 segundos
        healthChecker.scheduleAtFixedRate(this::checkBreakerHealth, 30, 30, TimeUnit.SECONDS);
    }
    
    public CircuitBreaker getBreaker(String serviceName) {
        return breakers.computeIfAbsent(serviceName, this::createCircuitBreaker);
    }
    
    private CircuitBreaker createCircuitBreaker(String serviceName) {
        return CircuitBreaker.builder()
            .failureThreshold(5)           // 5 fallos consecutivos
            .timeout(Duration.ofSeconds(10)) // 10 segundos timeout
            .retryAfter(Duration.ofMinutes(2)) // reintentar después de 2 minutos
            .onStateChange(this::logStateChange)
            .build();
    }
    
    public <T> T executeWithBreaker(String serviceName, Supplier<T> operation) {
        CircuitBreaker breaker = getBreaker(serviceName);
        return breaker.execute(operation);
    }
    
    private void checkBreakerHealth() {
        breakers.forEach((service, breaker) -> {
            if (breaker.getState() == HALF_OPEN) {
                // Intenta operación de health check
                try {
                    healthCheckService(service);
                    breaker.onSuccess(); // Marca como saludable
                } catch (Exception e) {
                    breaker.onFailure(); // Mantiene circuito abierto
                }
            }
        });
    }
}

// Uso en servicios:
@RestController
public class PaymentController {
    
    @PostMapping("/payment")
    public ResponseEntity<PaymentResult> processPayment(@RequestBody PaymentRequest request) {
        try {
            PaymentResult result = CircuitBreakerManager.INSTANCE.executeWithBreaker(
                "payment-gateway",
                () -> paymentGateway.processPayment(request)
            );
            return ResponseEntity.ok(result);
        } catch (CircuitBreakerOpenException e) {
            // Servicio no disponible, usar fallback
            return ResponseEntity.status(503)
                .body(PaymentResult.failed("Service temporarily unavailable"));
        }
    }
}
```

**¿Por qué Singleton aquí?**
- Necesitamos vista global del estado de todos los servicios
- Los circuit breakers deben ser compartidos entre requests
- El health checking debe ser centralizado
- Estado debe persistir durante toda la vida de la aplicación

**[CASO 3: NOTIFICATION TEMPLATE MANAGER - Multi-channel]**
```java
public class NotificationTemplateManager {
    private static final NotificationTemplateManager INSTANCE = new NotificationTemplateManager();
    
    private final Map<String, MessageTemplate> templates;
    private final List<NotificationChannel> channels;
    
    private NotificationTemplateManager() {
        // Cargar plantillas desde configuración
        this.templates = loadTemplatesFromConfig();
        
        // Inicializar canales de notificación
        this.channels = Arrays.asList(
            new EmailChannel(smtpConfig),
            new SmsChannel(twilioConfig), 
            new PushChannel(firebaseConfig),
            new SlackChannel(slackConfig)
        );
    }
    
    public static NotificationTemplateManager getInstance() {
        return INSTANCE;
    }
    
    public void sendNotification(String templateId, Map<String, Object> data, NotificationType... types) {
        MessageTemplate template = templates.get(templateId);
        if (template == null) {
            throw new IllegalArgumentException("Template not found: " + templateId);
        }
        
        for (NotificationType type : types) {
            NotificationChannel channel = getChannelForType(type);
            
            // Renderizar template con datos
            String message = template.render(data);
            
            // Enviar de manera asíncrona
            CompletableFuture.runAsync(() -> {
                try {
                    channel.send(message, data);
                    logNotificationSent(templateId, type, data);
                } catch (Exception e) {
                    logNotificationFailed(templateId, type, data, e);
                    // Implementar retry logic si es necesario
                }
            });
        }
    }
}

// Uso:
public class OrderService {
    public void completeOrder(Order order) {
        // ... lógica de negocio ...
        
        // Notificar al cliente por múltiples canales
        Map<String, Object> data = Map.of(
            "customerName", order.getCustomerName(),
            "orderId", order.getId(),
            "totalAmount", order.getTotalAmount(),
            "deliveryDate", order.getEstimatedDelivery()
        );
        
        NotificationTemplateManager.getInstance().sendNotification(
            "order-completion",
            data,
            EMAIL, PUSH, SMS
        );
    }
}
```

**[BENEFICIOS EN ENTERPRISE]**
✅ **Configuración única**: Una sola fuente de configuración
✅ **Resource pooling**: Conexiones caras reutilizadas eficientemente
✅ **Caching central**: Cache compartido entre componentes
✅ **Monitoring unificado**: Métricas y logs centralizados
✅ **State management**: Estado compartido cuando es apropiado

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 12: BEST PRACTICES [4 minutos]
==========================================

[MOSTRAR DIAPOSITIVA 12 - Mejores prácticas]

**[GUÍA COMPLETA DE IMPLEMENTACIÓN]**
Después de analizar todas las variantes, aquí están las mejores prácticas definitivas.

**[PATRÓN RECOMENDADO: BILL PUGH]**
Para el 90% de casos, usa Bill Pugh Pattern:

```java
public class ConfigurationManager {
    // Constructor privado - FUNDAMENTAL
    private ConfigurationManager() {
        // Cargar configuración, inicializar recursos
        loadConfiguration();
    }
    
    // Clase interna estática - CLAVE del patrón
    private static class ConfigurationHolder {
        private static final ConfigurationManager INSTANCE = new ConfigurationManager();
    }
    
    // Método de acceso público
    public static ConfigurationManager getInstance() {
        return ConfigurationHolder.INSTANCE;
    }
    
    // Métodos de negocio...
    public String getProperty(String key) { ... }
}
```

**[VALIDACIONES ANTES DE IMPLEMENTAR]**
Antes de crear cualquier Singleton, hazte estas preguntas críticas:

**1. ¿Realmente necesitas UNA SOLA instancia?**
```java
// ❌ Mal uso - no necesita ser único
public class MathUtils {
    public static MathUtils getInstance() { ... }
    public int add(int a, int b) { return a + b; }
}

// ✅ Mejor opción - métodos estáticos
public class MathUtils {
    private MathUtils() {} // Evitar instanciación
    public static int add(int a, int b) { return a + b; }
}
```

**2. ¿Puede ser reemplazado por Dependency Injection?**
```java
// ❌ Singleton problemático
public class DatabaseService {
    public static DatabaseService getInstance() { ... }
    public void save(Entity entity) { ... }
}

public class UserService {
    public void saveUser(User user) {
        DatabaseService.getInstance().save(user); // Acoplamiento fuerte
    }
}

// ✅ Con DI - más testeable y flexible
public class UserService {
    private final DatabaseService databaseService;
    
    public UserService(DatabaseService databaseService) {
        this.databaseService = databaseService;
    }
    
    public void saveUser(User user) {
        databaseService.save(user); // Inyectado, mockeable
    }
}
```

**3. ¿Es testeable fácilmente?**
```java
// ✅ Singleton testeable
public class ConfigurationManager {
    // ... implementación normal ...
    
    // Método SOLO para testing
    static void resetForTesting() {
        // Solo disponible en test classpath
        if (!isRunningInTest()) {
            throw new IllegalStateException("Only for testing");
        }
        // Reset logic...
    }
}
```

**[CHECKLIST DE CALIDAD COMPLETO]**

**✅ Implementación correcta:**
- [ ] Constructor privado
- [ ] Thread-safe (Bill Pugh, Enum, o Eager)
- [ ] Lazy loading cuando es apropiado
- [ ] Manejo de excepciones en constructor
- [ ] Serialization-safe si es necesario

**✅ Diseño sólido:**
- [ ] Una sola responsabilidad
- [ ] Stateless o estado inmutable preferiblemente
- [ ] No depende de otros Singletons
- [ ] Interfaz limpia y mínima

**✅ Testing y mantenimiento:**
- [ ] Unit tests posibles
- [ ] Métodos para testing si es necesario
- [ ] Documentación clara del por qué es Singleton
- [ ] Plan de migración a DI si es apropiado

**[ANTIPATRONES A EVITAR ABSOLUTAMENTE]**

**❌ God Object Singleton:**
```java
// ❌ Hace demasiadas cosas
public class SystemManager {
    public void configureDatabase() { ... }
    public void sendEmail() { ... }
    public void processPayment() { ... }
    public void generateReport() { ... }
    // Violación masiva de SRP
}
```

**❌ Singleton Dependency Chain:**
```java
// ❌ Singletons que dependen de otros Singletons
public class ServiceA {
    public void doSomething() {
        ServiceB.getInstance().callMethod();
        ServiceC.getInstance().anotherMethod();
    }
}
```

**❌ Global State Abuse:**
```java
// ❌ Estado mutable global
public enum UserContext {
    INSTANCE;
    
    private User currentUser; // ¡Problemático!
    
    public void setCurrentUser(User user) { 
        this.currentUser = user; // Estado global mutable
    }
}
```

**[RECOMENDACIÓN FINAL]**
El Singleton es una herramienta poderosa cuando se usa correctamente. La regla de oro:

**"Usa Singleton solo cuando NECESITES exactamente una instancia Y cuando las alternativas (como DI) no sean apropiadas para tu contexto específico."**

Para desarrollo moderno, considera Spring Framework o CDI que proporcionan lifecycle management sin los problemas del Singleton tradicional.

═══════════════════════════════════════════════════════════════

DIAPOSITIVA 13: CONCLUSIONES [3 minutos]
========================================

[MOSTRAR DIAPOSITIVA 13 - Conclusiones finales]

**[RESUMEN EJECUTIVO]**
Hemos recorrido un viaje completo por el patrón Singleton, desde sus fundamentos hasta implementaciones avanzadas y alternativas modernas.

**[LO QUE HEMOS APRENDIDO]**
✅ **6 implementaciones diferentes**: Cada una con sus trade-offs específicos
✅ **Thread-safety crítico**: En aplicaciones modernas, esto no es opcional
✅ **Trade-offs claros**: Performance vs Simplicidad, Seguridad vs Flexibilidad
✅ **Casos reales**: Aplicaciones concretas en sistemas enterprise

**[DECISIONES DE IMPLEMENTACIÓN]**
Para recapitular nuestras recomendaciones:

🥇 **Bill Pugh Pattern**: Tu primera opción para la mayoría de casos
- Lazy loading + Thread-safe + Performance óptimo

🥈 **Enum Singleton**: Cuando necesitas máxima seguridad
- Protección automática contra múltiples vectores de ataque

🥉 **Eager Initialization**: Para objetos simples y livianos
- Cuando lazy loading no aporta valor

**[EVOLUCIÓN DEL PATRÓN]**
El Singleton no existe en el vacío. En el contexto actual:

🔮 **Microservicios**: El estado global es más complejo
🔮 **Cloud-native**: Los containers manejan el lifecycle
🔮 **Frameworks modernos**: DI frameworks proporcionan alternativas
🔮 **Observabilidad**: Monitoreo distribuido cambia los requirements

**[MENSAJES CLAVE PARA LLEVAR]**

1. **Singleton es una herramienta, no una solución universal**
   - Úsalo solo cuando realmente necesites UNA instancia
   - Considera las alternativas antes de implementar

2. **El balance es crucial en software**
   - Thread-safety vs Performance
   - Simplicidad vs Flexibilidad
   - Control vs Acoplamiento

3. **Las alternativas modernas son poderosas**
   - Dependency Injection frameworks
   - Container-managed beans
   - Service registries

4. **El contexto determina la decisión**
   - Aplicaciones legacy vs modernas
   - Performance crítico vs flexibilidad
   - Recursos limitados vs escalabilidad

**[REFLEXIONES FINALES]**
El Singleton seguirá siendo relevante, pero su uso debe ser más thoughtful y contextual. En el desarrollo moderno, pregúntate siempre: "¿Hay una manera más flexible de lograr esto?"

**[PREGUNTAS PARA CONTINUAR APRENDIENDO]**
- ¿Cómo se comporta Singleton en arquitecturas distribuidas?
- ¿Qué patrones complementan o reemplazan a Singleton?
- ¿Cómo afectan los contenedores Docker al lifecycle de Singletons?
- ¿Qué consideraciones adicionales tiene Singleton en aplicaciones reactivas?

═══════════════════════════════════════════════════════════════

SESIÓN DE PREGUNTAS Y RESPUESTAS [8-10 minutos]
===============================================

**[PREPARACIÓN PARA PREGUNTAS COMUNES]**

**P: "¿Cuándo NO debería usar Singleton?"**
R: Evita Singleton cuando el testing es crítico, cuando necesitas flexibilidad para cambiar implementaciones, cuando usas frameworks DI, o cuando el "objeto único" es realmente un concepto de dominio que podría cambiar.

**P: "¿Cómo manejo las excepciones en el constructor?"**
R: Depende de la implementación. En Eager, la excepción previene que la clase se cargue. En lazy implementations, puedes catch y relanzar, o permitir que la excepción bubble up y reintentar en la siguiente llamada.

**P: "¿Singleton es compatible con microservicios?"**
R: Singleton dentro de un microservicio puede ser apropiado, pero evita estado compartido entre servicios. Considera service registries o configuration services para datos compartidos.

**P: "¿Cómo testeo código que usa Singleton?"**
R: Opciones: 1) Proporcionar métodos reset para testing, 2) Usar DI en lugar de Singleton, 3) Mockear a nivel de sistema, 4) Aislar la funcionalidad del Singleton detrás de interfaces.

¡Gracias por su atención! ¿Preguntas?

═══════════════════════════════════════════════════════════════

NOTAS ADICIONALES PARA EL EXPOSITOR:
===================================

**Timing sugerido:**
- Introducción: 2 min
- Diapositivas 1-3: 9 min (3 min c/u)
- Diapositivas 4-6: 13 min (4-5 min c/u)
- Diapositivas 7-8: 9 min (4-5 min c/u)
- Diapositivas 9-11: 12 min (4 min c/u)
- Diapositivas 12-13: 7 min (3-4 min c/u)
- Q&A: 8-10 min

**Consejos de presentación:**
- Usa ejemplos de código en vivo si es posible
- Enfatiza los problemas de concurrencia con diagramas
- Relaciona cada implementación con casos reales
- Mantén la energía alta durante las partes técnicas
- Invita preguntas durante la presentación, no solo al final

**Material de apoyo sugerido:**
- Diagramas de threads en whiteboard
- Código de ejemplo funcionando
- Métricas de performance si están disponibles
- Referencias a documentación oficial de Java

- **Cache manager**: Una sola instancia de cache evita duplicación de datos en memoria.

**Casos donde NO usar Singleton:**

- Cuando necesitamos múltiples instancias (obviamente)
- En testing, porque dificulta los unit tests al crear dependencias globales
- En sistemas concurrentes complejos donde puede convertirse en un cuello de botella
- Cuando viola los principios SOLID, especialmente el de responsabilidad única

Recuerden: el Singleton debe usarse con moderación. No todo debe ser singleton solo porque "es más fácil acceder globalmente".

DIAPOSITIVA 3: EAGER INITIALIZATION (3 minutos)
===============================================

[MOSTRAR DIAPOSITIVA 3]

Ahora vamos a ver las diferentes implementaciones. Empezamos con la más simple: Eager Initialization.

[LEER Y EXPLICAR EL CÓDIGO]

```java
public class ConfigurationManager {
    // Instancia creada al cargar la clase
    private static final ConfigurationManager INSTANCE = new ConfigurationManager();
    
    private Properties config;
    
    private ConfigurationManager() {
        // Constructor privado
        loadConfiguration();
    }
    
    public static ConfigurationManager getInstance() {
        return INSTANCE;
    }
}
```

**Explicación del código:**

1. **Línea 3**: `private static final ConfigurationManager INSTANCE` - La palabra clave `static` significa que la variable pertenece a la clase, no a una instancia específica. `final` asegura que no puede ser reasignada. La instancia se crea inmediatamente cuando la JVM carga la clase.

2. **Línea 7**: Constructor privado - Esto es CRÍTICO. Al hacer privado el constructor, impedimos que otras clases creen instancias usando `new ConfigurationManager()`.

3. **Línea 12**: El método `getInstance()` es público y estático, permitiendo acceso global sin necesidad de tener una instancia.

En el contexto de sistemas empresariales, este ConfigurationManager cargaría las configuraciones de conexión a los sistemas como bases de datos y APIs externas.

**Ventajas:**
- Thread-safe por naturaleza (la JVM garantiza que static final se inicializa una sola vez)
- Simple de implementar
- No hay overhead de sincronización

**Desventajas:**
- No es lazy - se crea aunque nunca se use
- Si el constructor lanza excepciones, no las podemos manejar elegantemente

DIAPOSITIVA 4: LAZY INITIALIZATION (3 minutos)
==============================================

[MOSTRAR DIAPOSITIVA 4]

Ahora veamos Lazy Initialization - creación bajo demanda.

[LEER Y EXPLICAR EL CÓDIGO]

```java
public class AuditLogger {
    private static AuditLogger instance;
    private List<AuditEvent> auditEvents;
    
    private AuditLogger() {
        auditEvents = new ArrayList<>();
    }
    
    public static AuditLogger getInstance() {
        if (instance == null) {
            instance = new AuditLogger();
        }
        return instance;
    }
}
```

**Explicación detallada:**

1. **Línea 2**: `private static AuditLogger instance;` - Note que aquí NO inicializamos la instancia inmediatamente. Se declara pero permanece null hasta que se necesite.

2. **Líneas 9-12**: El método `getInstance()` implementa la lógica de creación lazy. Primero verifica si la instancia existe (`if (instance == null)`), y solo si no existe, la crea.

3. **AuditLogger**: En sistemas empresariales, este logger registraría todas las acciones de auditoría: quién accedió a qué información, cuándo se realizaron transacciones, cambios en los datos, etc.

El método `logEvent()` crearía eventos como:
- Usuario "juan.perez" consultó saldo de energía a las 14:30
- Usuario "maria.gomez" realizó pago de $150,000 para servicios múltiples
- Admin "admin.sistema" modificó configuración de tarifas

**PROBLEMA CRÍTICO:**

Esta implementación tiene un problema grave en aplicaciones multi-hilo. Si dos hilos ejecutan `getInstance()` simultáneamente cuando `instance` es null, ambos pueden pasar la verificación `if (instance == null)` y crear dos instancias diferentes.

Esto viola completamente el principio del Singleton. Por eso esta implementación solo debe usarse en aplicaciones single-thread.

DIAPOSITIVA 5: SYNCHRONIZED METHOD (3 minutos)
==============================================

[MOSTRAR DIAPOSITIVA 5]

Para solucionar el problema de concurrencia, podemos sincronizar el método completo.

[EXPLICAR EL CÓDIGO]

```java
public static synchronized ConnectionPoolManager getInstance() {
    if (instance == null) {
        instance = new ConnectionPoolManager();
    }
    return instance;
}
```

**Explicación de sincronización:**

La palabra clave `synchronized` en un método estático significa que solo un hilo puede ejecutar este método a la vez. Java usa el objeto Class como monitor de sincronización.

**ConnectionPoolManager en Sistemas Empresariales:**

Este singleton gestiona pools de conexiones para:

1. **Mainframe Pool**: Conexiones al sistema IBM Z/OS donde están los datos históricos de energía y acueducto
2. **Oracle Pool**: Conexiones a las bases de datos Oracle en Solaris donde se manejan las cuentas corrientes

**Configuración explicada:**

```java
// Configuración pool Mainframe
HikariConfig mainframeConfig = new HikariConfig();
        mainframeConfig.setJdbcUrl("jdbc:db2://database.company.com:50000/ENTERPRISE");
mainframeConfig.setMaximumPoolSize(10);
```

- **HikariCP**: Es una librería de pool de conexiones muy eficiente
- **jdbc:db2**: Driver para conectar a bases de datos DB2 del mainframe
- **MaximumPoolSize(10)**: Máximo 10 conexiones simultáneas al mainframe

¿Por qué un pool? Crear una conexión a base de datos es costoso (puede tomar 100-500ms). Con un pool, mantenemos conexiones abiertas y las reutilizamos.

**Problema de performance:**

Aunque es thread-safe, sincronizar todo el método significa que incluso después de que la instancia esté creada, todos los accesos posteriores deben esperar el lock. Esto es ineficiente.

DIAPOSITIVA 6: DOUBLE-CHECKED LOCKING (4 minutos)
=================================================

[MOSTRAR DIAPOSITIVA 6]

Para optimizar la performance, usamos Double-Checked Locking.

[EXPLICAR EL CÓDIGO LÍNEA POR LÍNEA]

```java
public static CacheManager getInstance() {
    if (instance == null) {                    // Primera verificación (sin lock)
        synchronized (CacheManager.class) {
            if (instance == null) {            // Segunda verificación (con lock)
                instance = new CacheManager();
            }
        }
    }
    return instance;
}
```

**Explicación del patrón:**

1. **Primera verificación** (línea 2): Sin sincronización, verificamos si la instancia ya existe. Si existe, retornamos inmediatamente sin entrar al bloque sincronizado.

2. **Bloque sincronizado** (línea 3): Solo si la instancia es null, entramos al bloque sincronizado.

3. **Segunda verificación** (línea 4): Dentro del bloque sincronizado, verificamos nuevamente porque otro hilo pudo haber creado la instancia mientras esperábamos el lock.

**CRÍTICO - volatile:**

```java
private static volatile CacheManager instance;
```

La palabra clave `volatile` es ESENCIAL. Sin ella, las optimizaciones del compilador y CPU pueden causar que un hilo vea una instancia "parcialmente construida". volatile garantiza:
- Visibilidad: cambios en un hilo son inmediatamente visibles a otros hilos
- Orden: prohíbe reordenamiento de instrucciones

**CacheManager en Sistemas Empresariales:**

Este gestor implementa un cache de dos niveles:

1. **L1 (Local Cache)**: Caffeine cache en memoria local para acceso ultra-rápido
2. **L2 (Distributed Cache)**: Redis para compartir cache entre múltiples instancias del microservicio

**Ejemplo de uso:**
- Usuario consulta saldo → Se cachea en L1 y L2
- Próxima consulta del mismo usuario → Se responde desde L1 (microsegundos)
- Consulta desde otra instancia del servicio → Se responde desde L2 (milisegundos)
- Sin cache → Consulta al mainframe (segundos)

DIAPOSITIVA 7: BILL PUGH PATTERN (3 minutos)
============================================

[MOSTRAR DIAPOSITIVA 7]

El patrón Bill Pugh es considerado la mejor práctica para Singleton lazy.

[EXPLICAR EL CÓDIGO]

```java
private static class CircuitBreakerHolder {
    private static final CircuitBreakerManager INSTANCE = new CircuitBreakerManager();
}

public static CircuitBreakerManager getInstance() {
    return CircuitBreakerHolder.INSTANCE;
}
```

**¿Cómo funciona la magia?**

1. **Clase interna estática**: `CircuitBreakerHolder` es una clase nested static
2. **Lazy loading por JVM**: La JVM no carga clases internas hasta que son referenciadas
3. **Thread-safety garantizado**: La JVM garantiza que la inicialización de static final es thread-safe
4. **Sin overhead**: No hay sincronización explícita, todo lo maneja la JVM

**CircuitBreakerManager explicado:**

Un Circuit Breaker es un patrón que previene cascadas de fallos. En sistemas empresariales:

```java
CircuitBreakerConfig mainframeConfig = CircuitBreakerConfig.custom()
    .failureRateThreshold(60)                    // 60% fallos
    .waitDurationInOpenState(Duration.ofSeconds(60))  // 60s abierto
    .slidingWindowSize(10)                       // ventana 10 requests
    .minimumNumberOfCalls(5)                     // mínimo 5 calls
    .build();
```

**Estados del Circuit Breaker:**

1. **CLOSED**: Normal, permite todas las llamadas
2. **OPEN**: Demasiados fallos, bloquea todas las llamadas por 60 segundos
3. **HALF-OPEN**: Después de 60s, permite algunas llamadas de prueba

**Escenario real**: Si el mainframe falla, en lugar de que todos los microservicios colapsen intentando conectarse repetidamente, el circuit breaker los protege, retornando un error inmediato y permitiendo que el sistema siga funcionando parcialmente.

DIAPOSITIVA 8: ENUM SINGLETON (4 minutos)
=========================================

[MOSTRAR DIAPOSITIVA 8]

El Enum Singleton es considerado la implementación más robusta.

[EXPLICAR EL CÓDIGO]

```java
public enum NotificationService {
    INSTANCE;
    
    // Constructor ejecutado una sola vez
    NotificationService() {
        initializeServices();
    }
    
    public static NotificationService getInstance() {
        return INSTANCE;
    }
}
```

**¿Por qué Enum es especial?**

1. **Thread-safety**: Los enums son thread-safe por naturaleza
2. **Serialización segura**: La JVM garantiza que después de deserializar, tendremos la misma instancia
3. **Protección contra Reflection**: No se puede usar reflection para crear nuevas instancias
4. **Protección contra clonación**: Los enums no se pueden clonar

**NotificationService en Sistemas Empresariales:**

Este servicio maneja notificaciones multicanal:

```java
private void initializeServices() {
    // Configuración servicio email
    emailService = EmailService.builder()
        .smtpHost("smtp.company.com")
        .smtpPort(587)
        .username("noreply@company.com")
        .password(System.getenv("SMTP_PASSWORD"))
        .build();
}
```

**Explicación de configuraciones:**

- **SMTP**: Simple Mail Transfer Protocol para envío de emails
- **Puerto 587**: Puerto estándar para SMTP con TLS (encriptación)
- **System.getenv()**: Lee variables de entorno, más seguro que hardcodear passwords

**Ejemplo de notificación multicanal:**

```java
public void sendNotification(NotificationRequest request) {
    switch (request.getChannel()) {
        case ALL:
            sendMultiChannel(request);
            break;
    }
}

private void sendMultiChannel(NotificationRequest request) {
    CompletableFuture.allOf(
        CompletableFuture.runAsync(() -> emailService.send(...)),
        CompletableFuture.runAsync(() -> smsService.send(...)),
        CompletableFuture.runAsync(() -> pushService.send(...))
    );
}
```

**CompletableFuture explicado:**

- **Asíncrono**: Los tres servicios (email, SMS, push) se ejecutan en paralelo
- **allOf()**: Espera a que todos terminen
- **runAsync()**: Ejecuta cada tarea en un hilo separado

**Escenario real**: Cuando un usuario paga sus servicios, se envía simultáneamente:
- Email con recibo detallado
- SMS con confirmación
- Push notification a la app móvil

DIAPOSITIVA 9: COMPARACIÓN (2 minutos)
======================================

[MOSTRAR TABLA COMPARATIVA]

Vamos a resumir cuándo usar cada implementación:

**Eager Initialization**: 
- Úsenlo para objetos livianos que siempre van a necesitar
- Como configuraciones básicas del sistema

**Lazy Simple**: 
- Solo en aplicaciones single-thread
- Prácticamente nunca en aplicaciones modernas

**Synchronized Method**: 
- Evítenlo, el overhead es demasiado grande

**Double-Checked Locking**: 
- Solo en casos muy específicos donde necesiten optimización extrema
- Requiere entender muy bien concurrencia

**Bill Pugh**: 
- **RECOMENDADO** para la mayoría de casos
- Combina lazy loading, thread-safety y performance

**Enum**: 
- **MÁS SEGURO** cuando necesiten máxima robustez
- Especialmente para servicios críticos

DIAPOSITIVA 10: PROBLEMAS Y ALTERNATIVAS (3 minutos)
====================================================

[MOSTRAR DIAPOSITIVA 10]

El Singleton tiene problemas serios en aplicaciones modernas:

**1. Dificultad en Testing:**

```java
// ❌ Problemático
@Test
public void testPaymentProcessing() {
    ConnectionPoolManager poolManager = ConnectionPoolManager.getInstance();
    // No podemos mockear fácilmente
}
```

El problema: en unit tests queremos aislar la funcionalidad. Si nuestro código depende de un singleton real, no podemos reemplazarlo con un mock para testing.

**✅ Solución moderna - Dependency Injection:**

```java
@Service
public class PaymentService {
    private final ConnectionPoolManager poolManager;
    
    // Inyección por constructor
    public PaymentService(ConnectionPoolManager poolManager) {
        this.poolManager = poolManager;
    }
}
```

Con Spring Framework:
- La instancia es singleton por defecto
- Pero podemos inyectar mocks en testing
- Mejor testabilidad y flexibilidad

**2. Violación de Responsabilidad Única:**
- El singleton gestiona su propia creación Y su lógica de negocio
- Debería hacer solo una cosa

**3. Acoplamiento Fuerte:**
- Las clases quedan acopladas directamente al singleton
- Difícil cambiar implementaciones

**Alternativa Spring:**

```java
@Component
@Scope("singleton")  // Singleton por defecto
public class CacheManager {
    // Spring gestiona el ciclo de vida
}
```

Spring maneja la creación, inyección y ciclo de vida, dándonos los beneficios del singleton sin los problemas.

DIAPOSITIVA 11: CASOS REALES EN SISTEMAS EMPRESARIALES (3 minutos)
=======================================================

[MOSTRAR DIAPOSITIVA 11]

Veamos implementaciones reales en nuestro proyecto:

**1. Legacy Adapter Factory:**

```java
public enum LegacyAdapterFactory {
    INSTANCE;
    
    private final Map<TipoSistema, LegacySystemAdapter> adapters;
    
    public LegacySystemAdapter getAdapter(TipoSistema tipo) {
        return adapters.get(tipo);
    }
}
```

**¿Por qué usar Factory como singleton?**

En sistemas empresariales modernos tenemos tres tipos de sistemas diferentes:
- **Mainframe IBM**: Datos históricos de energía (COBOL/DB2)
- **Oracle Solaris**: Cuentas corrientes de acueducto (PL/SQL)
- **API REST**: Sistema de telecomunicaciones (moderno)

Cada uno requiere un adaptador diferente para traducir formatos. El factory singleton asegura que:
- Solo hay una instancia de cada adaptador
- Acceso rápido sin recrear objetos
- Configuración centralizada

**2. Message Translator:**

```java
public String translateFromEBCDIC(byte[] ebcdicData) {
    // EBCDIC → JSON translation
    return formatters.get("EBCDIC").parse(ebcdicData);
}

public String translateToPLSQL(JsonNode jsonData) {
    // JSON → PL/SQL translation
    return formatters.get("PLSQL").format(jsonData);
}
```

**EBCDIC explicado:**
- Extended Binary Coded Decimal Interchange Code
- Codificación de caracteres usada en mainframes IBM
- Diferente a ASCII/UTF-8 que usamos normalmente
- Necesitamos traducir datos del mainframe a JSON moderno

**Flujo real de datos:**
1. Microservicio recibe petición de saldo
2. Usa MessageTranslator para convertir JSON → EBCDIC
3. Envía al mainframe
4. Recibe respuesta en EBCDIC
5. Usa MessageTranslator para convertir EBCDIC → JSON
6. Retorna al cliente

DIAPOSITIVA 12: BEST PRACTICES (2 minutos)
==========================================

[MOSTRAR DIAPOSITIVA 12]

**Buenas prácticas esenciales:**

1. **Prefiere Enum Singleton** para casos simples donde necesites máxima robustez

2. **Usa Bill Pugh** cuando tengas lógica compleja de inicialización

3. **Implementa Serializable correctamente:**

```java
// Protección contra serialización
private Object readResolve() {
    return INSTANCE;
}
```

Esto asegura que después de deserializar, obtenemos la misma instancia singleton.

4. **Protege contra Reflection:**

```java
private SingletonClass() {
    if (INSTANCE != null) {
        throw new RuntimeException("Use getInstance() method");
    }
}
```

5. **Protege contra clonación:**

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException("Singleton cannot be cloned");
}
```

**Anti-patrones a evitar:**

- No uses lazy loading sin thread-safety
- Evita synchronized methods (usa Bill Pugh o enum)
- No hagas singleton todo lo que "parece" global
- No ignores el testing

DIAPOSITIVA 13: CONCLUSIONES (2 minutos)
========================================

[MOSTRAR DIAPOSITIVA 13]

**Resumen final:**

El patrón Singleton debe usarse con moderación y sabiduría:

**✅ Usar cuando necesites:**
- Exactamente una instancia (configuración, pools, caches)
- Control de acceso a recursos caros
- Estado global bien justificado

**❌ Evitar cuando:**
- Complique el testing
- Viole principios SOLID
- Puedas usar dependency injection

**Recomendación para aplicaciones modernas:**

```
Spring/CDI → Dependency Injection (preferido)
Casos legacy específicos → Enum Singleton  
Recursos compartidos simples → Bill Pugh
```

**El futuro del Singleton:**

En arquitecturas modernas:
- **Microservicios**: Cada servicio es conceptualmente singleton
- **Cloud Native**: Preferimos stateless sobre stateful singletons
- **Containers**: Kubernetes/Docker gestionan instancias únicas

**Para Sistemas Empresariales:**
- Usamos singletons para componentes de infraestructura (adapters, translators)
- Dependency injection para lógica de negocio
- Enum singletons para máxima robustez en componentes críticos

PREGUNTAS Y RESPUESTAS (5 minutos)
=================================

Ahora estoy abierto a responder cualquier pregunta sobre:

- Implementaciones específicas del patrón Singleton
- Aplicaciones en sistemas empresariales
- Comparaciones entre diferentes enfoques
- Alternativas modernas como dependency injection
- Casos de uso específicos en sistemas legacy

¡Muchas gracias por su atención!

===============================================================================
NOTAS ADICIONALES PARA EL EXPOSITOR:
===============================================================================

TIMING SUGERIDO:
- Introducción: 2-3 minutos
- Diapositivas 1-2: 4 minutos  
- Diapositivas 3-5: 9 minutos (implementaciones básicas)
- Diapositivas 6-8: 10 minutos (implementaciones avanzadas)
- Diapositivas 9-10: 5 minutos (comparación y problemas)
- Diapositivas 11-13: 7 minutos (casos reales y conclusiones)
- Preguntas: 5 minutos
- TOTAL: 40-45 minutos

TIPS DE PRESENTACIÓN:
- Enfatiza los problemas de concurrencia con ejemplos
- Usa analogías del mundo real para explicar conceptos técnicos
- Conecta siempre con ejemplos de sistemas empresariales para hacer relevante
- Prepárate para preguntas sobre performance y testing
- Ten ejemplos adicionales listos por si necesitas clarificar

POSIBLES PREGUNTAS Y RESPUESTAS:

Q: "¿Por qué no usar siempre Enum Singleton si es el más seguro?"
A: "Porque no todos los casos necesitan esa robustez. Para casos simples, Bill Pugh es más claro y flexible. Enum es mejor para servicios críticos donde la seguridad es paramount."

Q: "¿Cómo se comporta el Singleton en aplicaciones distribuidas?"
A: "En microservicios, cada instancia de servicio tendría su propio singleton. Para estado verdaderamente global, necesitaríamos external stores como Redis o bases de datos."

Q: "¿Qué pasa si necesito pasar parámetros al constructor?"
A: "Eso es una señal de que quizás no debería ser singleton. Considera usar Factory pattern o dependency injection con configuración externa."

===============================================================================
