GUIÃ“N COMPLETO PARA EXPOSICIÃ“N: PATRÃ“N SINGLETON
==============================================
Universidad AutÃ³noma de Occidente - IngenierÃ­a de Software 2
DuraciÃ³n: 45 minutos | Septiembre 2025
==============================================

INTRODUCCIÃ“N [2 minutos]
========================

Buenos dÃ­as. Hoy exploraremos el patrÃ³n Singleton, uno de los patrones mÃ¡s conocidos pero tambiÃ©n mÃ¡s debatidos en la ingenierÃ­a de software. Veremos 6 implementaciones diferentes, desde la mÃ¡s simple hasta la mÃ¡s robusta, con ejemplos prÃ¡cticos de sistemas empresariales.

Durante los prÃ³ximos 45 minutos cubriremos:
- Conceptos fundamentales del patrÃ³n
- 6 implementaciones con sus trade-offs
- Casos reales en sistemas enterprise
- Alternativas modernas y mejores prÃ¡cticas

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 1: INTRODUCCIÃ“N AL PATRÃ“N SINGLETON [4 minutos]
==========================================================

[MOSTRAR DIAPOSITIVA 1 - Conceptos fundamentales]

**[EXPLICAR DEFINICIÃ“N]**
El patrÃ³n Singleton es un patrÃ³n creacional que resuelve un problema especÃ­fico: garantizar que una clase tenga exactamente UNA instancia y proporcionar acceso global controlado a ella.

**[DETALLE DE GARANTÃAS]**
Â¿QuÃ© significa "una sola instancia"? Significa que sin importar cuÃ¡ntas veces llamemos al constructor o mÃ©todo de acceso, siempre obtendremos LA MISMA instancia en memoria. Es como tener un Ãºnico gerente general en una empresa - solo puede haber uno.

**[EXPLICAR ACCESO GLOBAL]**
El acceso global controlado significa que cualquier parte de nuestro cÃ³digo puede acceder a esta instancia, pero de manera controlada - no a travÃ©s de una variable global caÃ³tica, sino mediante un mÃ©todo bien definido.

**[LAZY INITIALIZATION]**
La inicializaciÃ³n perezosa o "lazy initialization" es crear el objeto solo cuando realmente se necesita. Es como no contratar un empleado hasta que realmente tengamos trabajo para Ã©l.

**[EJEMPLO PRÃCTICO DETALLADO]**
Veamos el ejemplo de ConfigurationManager. Sin Singleton:
```java
// âŒ ProblemÃ¡tico - mÃºltiples configuraciones
ConfigurationManager config1 = new ConfigurationManager(); // Lee archivo config.properties
ConfigurationManager config2 = new ConfigurationManager(); // Lee archivo OTRA VEZ
```
Cada instancia leerÃ­a el archivo de configuraciÃ³n, desperdiciarÃ­a memoria y podrÃ­a tener valores inconsistentes si el archivo cambia.

Con Singleton:
```java
// âœ… Eficiente - una sola configuraciÃ³n
ConfigurationManager config1 = ConfigurationManager.getInstance();
ConfigurationManager config2 = ConfigurationManager.getInstance();
// config1 == config2 (misma referencia en memoria)
```

**[CUÃNDO USAR - CRITERIOS ESPECÃFICOS]**
El Singleton es apropiado cuando:
1. Necesitas exactamente UNA instancia - no cero, no dos, UNA
2. Esta instancia debe ser accesible globalmente
3. La instancia controla acceso a un recurso compartido

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 2: CUÃNDO USAR SINGLETON [3 minutos]
===============================================

[MOSTRAR DIAPOSITIVA 2 - Casos de uso y framework de decisiÃ³n]

**[CASOS DE USO DETALLADOS]**
PermÃ­tanme explicar cada caso con ejemplos concretos de sistemas empresariales:

**ConfiguraciÃ³n Global:**
En un sistema bancario, necesitamos configurar URLs de APIs, timeouts, credenciales. Una sola instancia garantiza consistencia:
```java
String apiUrl = ConfigManager.getInstance().getProperty("api.payments.url");
int timeout = ConfigManager.getInstance().getIntProperty("api.timeout", 30000);
```

**Pool de Conexiones:**
Las conexiones a base de datos son costosas de crear. Un pool centralizado las reutiliza eficientemente:
```java
Connection conn = ConnectionPool.getInstance().getConnection();
// Usa la conexiÃ³n
ConnectionPool.getInstance().releaseConnection(conn);
```

**Logging Centralizado:**
Un solo logger evita conflictos de escritura y garantiza formato consistente:
```java
Logger.getInstance().info("User " + userId + " login successful");
Logger.getInstance().error("Payment failed for transaction " + txId);
```

**Cache Manager:**
Una cache centralizada evita duplicaciÃ³n de datos y optimiza memoria:
```java
UserData user = CacheManager.getInstance().get("user:" + userId);
if (user == null) {
    user = database.getUser(userId);
    CacheManager.getInstance().put("user:" + userId, user);
}
```

**[FRAMEWORK DE DECISIÃ“N]**
Antes de implementar Singleton, pregÃºntate:
- Â¿Realmente necesito exactamente UNA instancia?
- Â¿Es esta instancia un recurso compartido?
- Â¿El acceso global estÃ¡ justificado?
- Â¿PodrÃ­a usar dependency injection en su lugar?

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 3: EAGER INITIALIZATION [4 minutos]
===============================================

[MOSTRAR DIAPOSITIVA 3 - Eager Initialization]

**[EXPLICAR EL CONCEPTO]**
Eager Initialization significa que la instancia se crea INMEDIATAMENTE cuando la JVM carga la clase, no cuando se llama getInstance() por primera vez.

**[ANÃLISIS LÃNEA POR LÃNEA DEL CÃ“DIGO]**
Veamos cada parte del cÃ³digo:

```java
private static final DatabaseManager INSTANCE = new DatabaseManager();
```
- `static`: Pertenece a la clase, no a una instancia especÃ­fica
- `final`: Una vez asignada, no puede cambiar la referencia
- `= new DatabaseManager()`: Se ejecuta cuando la JVM carga la clase

```java
private DatabaseManager() {
    // Constructor privado - CRÃTICO
}
```
El constructor privado es FUNDAMENTAL. Impide que cÃ³digo externo haga `new DatabaseManager()`, garantizando que solo existe la instancia controlada.

```java
public static DatabaseManager getInstance() {
    return INSTANCE;  // Solo retorna la referencia
}
```
Este mÃ©todo es extremadamente rÃ¡pido - simplemente retorna una referencia existente, sin verificaciones ni creaciÃ³n.

**[FLUJO DE EJECUCIÃ“N DETALLADO]**
1. **Carga de clase**: Cuando la JVM encuentra la primera referencia a DatabaseManager
2. **Instancia creada**: Se ejecuta `new DatabaseManager()` automÃ¡ticamente
3. **getInstance()**: Simplemente retorna la referencia ya existente
4. **Accesos posteriores**: Todos retornan la misma referencia, instantÃ¡neamente

**[THREAD-SAFETY AUTOMÃTICO]**
Â¿Por quÃ© es thread-safe? Porque la JVM garantiza que la inicializaciÃ³n de campos `static final` ocurre de manera atÃ³mica. Es imposible que dos threads vean estados inconsistentes.

**[VENTAJAS ESPECÃFICAS]**
âœ… **Simplicidad extrema**: El cÃ³digo es muy fÃ¡cil de entender
âœ… **Performance de acceso**: getInstance() es prÃ¡cticamente instantÃ¡neo
âœ… **Thread-safety garantizado**: Sin necesidad de sincronizaciÃ³n

**[DESVENTAJAS ESPECÃFICAS]**
âŒ **Desperdicio de memoria**: Si nunca usas la instancia, ya estÃ¡ creada
âŒ **Impacto en startup**: Si el constructor es costoso, afecta el tiempo de inicio
âŒ **Manejo de excepciones**: Si falla el constructor, la clase no se puede cargar

**[CUÃNDO ES IDEAL]**
- Constructor simple y rÃ¡pido
- Sabes que SIEMPRE necesitarÃ¡s la instancia
- La aplicaciÃ³n tiene recursos abundantes
- El tiempo de startup no es crÃ­tico

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 4: LAZY INITIALIZATION [4 minutos]
==============================================

[MOSTRAR DIAPOSITIVA 4 - Lazy Initialization]

**[CONCEPTO FUNDAMENTAL]**
Lazy Initialization es lo opuesto a Eager - la instancia se crea solo cuando se llama getInstance() por primera vez. Es la implementaciÃ³n mÃ¡s intuitiva del patrÃ³n.

**[ANÃLISIS DEL CÃ“DIGO]**
```java
private static DatabaseConnectionPool instance;  // Inicialmente null
```
La variable instance inicia como null - no hay objeto creado aÃºn.

```java
if (instance == null) {  // Primera verificaciÃ³n
    instance = new DatabaseConnectionPool();  // CreaciÃ³n costosa
}
return instance;
```

**[FLUJO DE EJECUCIÃ“N PASO A PASO]**
1. **Primera llamada**: instance es null â†’ se crea el objeto â†’ se retorna
2. **Llamadas posteriores**: instance no es null â†’ se retorna directamente

**[EL PROBLEMA DE CONCURRENCIA]**
AquÃ­ estÃ¡ el gran problema. Imaginen este escenario:

```
Tiempo 1: Thread A llama getInstance()
Tiempo 2: Thread A evalÃºa (instance == null) â†’ TRUE
Tiempo 3: Thread B llama getInstance()  
Tiempo 4: Thread B evalÃºa (instance == null) â†’ TRUE (Â¡aÃºn!)
Tiempo 5: Thread A ejecuta new DatabaseConnectionPool() â†’ Instancia A
Tiempo 6: Thread B ejecuta new DatabaseConnectionPool() â†’ Instancia B âŒ
```

Â¡Tenemos DOS instancias! El patrÃ³n Singleton estÃ¡ roto.

**[RACE CONDITION EXPLICADA]**
Una race condition ocurre cuando mÃºltiples threads acceden y modifican datos compartidos, y el resultado depende del timing. En este caso, ambos threads "ganan la carrera" de crear la instancia.

**[CUÃNDO ES APROPIADO]**
Lazy initialization sin sincronizaciÃ³n solo es seguro en aplicaciones single-thread:
- Scripts simples
- Aplicaciones de escritorio con un solo thread
- Prototipos y demos

**[VENTAJAS]**
âœ… **Eficiencia de memoria**: Solo usa memoria cuando necesita el objeto
âœ… **Startup rÃ¡pido**: No impacta el tiempo de inicio de la aplicaciÃ³n
âœ… **Simplicidad**: CÃ³digo fÃ¡cil de entender

**[DESVENTAJAS CRÃTICAS]**
âŒ **NO thread-safe**: Puede crear mÃºltiples instancias
âŒ **Impredecible**: El comportamiento cambia segÃºn el timing
âŒ **Bugs silenciosos**: Puede funcionar en desarrollo pero fallar en producciÃ³n

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 5: SYNCHRONIZED METHOD [4 minutos]
==============================================

[MOSTRAR DIAPOSITIVA 5 - Synchronized Method]

**[LA SOLUCIÃ“N OBVIA AL PROBLEMA]**
Si Lazy Initialization tiene problemas de concurrencia, la soluciÃ³n mÃ¡s directa es sincronizar todo el mÃ©todo getInstance().

**[ANÃLISIS DEL CÃ“DIGO]**
```java
public static synchronized SecurityManager getInstance() {
    if (instance == null) {
        instance = new SecurityManager();
    }
    return instance;
}
```
La palabra clave `synchronized` garantiza que solo UN thread puede ejecutar este mÃ©todo a la vez.

**[CÃ“MO FUNCIONA LA SINCRONIZACIÃ“N]**
Cuando un thread llama a getInstance():
1. **Obtiene el lock**: Solo este thread puede continuar
2. **Ejecuta el cÃ³digo**: Verifica, crea si necesario, retorna
3. **Libera el lock**: Otros threads pueden proceder

**[FLUJO CON MÃšLTIPLES THREADS]**
```
Thread A: Obtiene lock â†’ verifica null â†’ crea instancia â†’ libera lock
Thread B: Espera lock â†’ obtiene lock â†’ verifica NOT null â†’ retorna â†’ libera lock
Thread C: Espera lock â†’ obtiene lock â†’ verifica NOT null â†’ retorna â†’ libera lock
```

**[EL PROBLEMA DE PERFORMANCE]**
AquÃ­ estÃ¡ el gran problema: la sincronizaciÃ³n es necesaria solo DURANTE LA CREACIÃ“N. Una vez creada la instancia, cada acceso posterior aÃºn requiere obtener y liberar el lock innecesariamente.

**[EJEMPLO DE DESPERDICIO]**
```java
// PRIMERA llamada: Lock necesario âœ…
SecurityManager sm1 = SecurityManager.getInstance(); // 100 microsegundos

// SIGUIENTES 10,000 llamadas: Lock innecesario âŒ
for (int i = 0; i < 10000; i++) {
    SecurityManager sm = SecurityManager.getInstance(); // 50 microsegundos c/u
}
```
El overhead se acumula significativamente en aplicaciones de alto trÃ¡fico.

**[IMPACTO EN ESCALABILIDAD]**
En un sistema web con 1000 requests/segundo:
- Sin sincronizaciÃ³n: getInstance() toma ~1 microsegundo
- Con sincronizaciÃ³n: getInstance() toma ~50 microsegundos
- Impacto total: 49,000 microsegundos extra por segundo = 5% de CPU desperdiciada

**[CUÃNDO ES ACEPTABLE]**
- Aplicaciones con pocas llamadas a getInstance()
- Sistemas donde la simplicidad es mÃ¡s importante que performance
- Prototipos donde el rendimiento no es crÃ­tico

**[CARACTERÃSTICAS CLAVE]**
âœ… **Thread-safe**: Sin race conditions
âœ… **Simple**: FÃ¡cil de implementar y entender
âœ… **Lazy**: CreaciÃ³n bajo demanda
âŒ **Performance**: Overhead en cada acceso
âŒ **Escalabilidad**: Cuello de botella en alta concurrencia

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 6: DOUBLE-CHECKED LOCKING [5 minutos]
=================================================

[MOSTRAR DIAPOSITIVA 6 - Double-Checked Locking]

**[LA OPTIMIZACIÃ“N INTELIGENTE]**
Double-Checked Locking optimiza el Synchronized Method eliminando la sincronizaciÃ³n innecesaria despuÃ©s de la creaciÃ³n. Es una tÃ©cnica elegante pero compleja.

**[ANÃLISIS DETALLADO DEL CÃ“DIGO]**
```java
private static volatile CacheManager instance;  // âš ï¸ VOLATILE es crÃ­tico
```
`volatile` garantiza que todos los threads vean el mismo valor de instance. Sin volatile, el patrÃ³n estÃ¡ ROTO.

```java
public static CacheManager getInstance() {
    if (instance == null) {  // ğŸ” PRIMERA verificaciÃ³n (sin lock)
        synchronized (CacheManager.class) {  // ğŸ” Obtener lock
            if (instance == null) {  // ğŸ” SEGUNDA verificaciÃ³n (con lock)
                instance = new CacheManager();
            }
        }
    }
    return instance;
}
```

**[Â¿POR QUÃ‰ DOS VERIFICACIONES?]**
Imaginemos quÃ© pasarÃ­a con una sola verificaciÃ³n:

```java
// âŒ INCORRECTO - una sola verificaciÃ³n
if (instance == null) {
    synchronized (CacheManager.class) {
        instance = new CacheManager();  // Â¡Sobrescribe instancia existente!
    }
}
```

Con una verificaciÃ³n:
1. Thread A pasa la verificaciÃ³n (instance == null)
2. Thread B pasa la verificaciÃ³n (instance == null)  
3. Thread A obtiene lock, crea instancia
4. Thread B obtiene lock, Â¡SOBRESCRIBE la instancia!

**[FLUJO CON DOS VERIFICACIONES]**
Escenario exitoso:
```
Thread A: (instance == null) â†’ true â†’ obtiene lock â†’ (instance == null) â†’ true â†’ crea
Thread B: (instance == null) â†’ true â†’ espera lock â†’ obtiene lock â†’ (instance == null) â†’ FALSE â†’ sale
```

Escenario de acceso normal:
```
Thread C: (instance == null) â†’ FALSE â†’ retorna inmediatamente (Â¡sin lock!)
```

**[LA IMPORTANCIA CRÃTICA DE VOLATILE]**
Sin `volatile`, pueden ocurrir reordenamientos de instrucciones:

```java
// El compilador podrÃ­a reordenar:
instance = new CacheManager();
// Como:
1. instance = allocate_memory();  // instance no es null pero objeto no estÃ¡ construido
2. construct_CacheManager();     // construir objeto
3. // Otro thread ve instance != null pero objeto no estÃ¡ listo âŒ
```

`volatile` previene este reordenamiento y garantiza visibilidad entre threads.

**[VENTAJAS Y TRADE-OFFS]**
âœ… **Performance optimizada**: Lock solo durante creaciÃ³n
âœ… **Thread-safe**: Con volatile, es completamente seguro
âœ… **Lazy loading**: CreaciÃ³n bajo demanda

âŒ **Complejidad**: FÃ¡cil de implementar incorrectamente
âŒ **Dependencia de volatile**: Requiere comprensiÃ³n profunda del memory model
âŒ **Debugging**: MÃ¡s difÃ­cil de debuggear problemas

**[CUÃNDO USARLO]**
- Performance crÃ­tico con acceso frecuente
- Sistemas de alto trÃ¡fico
- Cuando realmente entiendes volatile y memory models
- Equipos de desarrollo experimentados

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 7: BILL PUGH PATTERN [5 minutos]
===========================================

[MOSTRAR DIAPOSITIVA 7 - Bill Pugh Pattern]

**[LA SOLUCIÃ“N ELEGANTE]**
El Bill Pugh Pattern, tambiÃ©n conocido como "Initialization-on-demand holder idiom", es considerado la MEJOR implementaciÃ³n de Singleton para la mayorÃ­a de casos. Combina lazy loading, thread-safety y performance sin complejidad.

**[ANÃLISIS ARQUITECTURAL DEL CÃ“DIGO]**
```java
public class LogManager {
    private LogManager() {
        // Constructor privado como siempre
    }
    
    // ğŸ—ï¸ La clase interna estÃ¡tica es la CLAVE
    private static class LogManagerHolder {
        private static final LogManager INSTANCE = new LogManager();
    }
    
    public static LogManager getInstance() {
        return LogManagerHolder.INSTANCE;  // Acceso a la clase interna
    }
}
```

**[LA GENIALIDAD DEL DISEÃ‘O]**
La brillantez estÃ¡ en la clase interna estÃ¡tica `LogManagerHolder`. Esta clase:
1. **No se carga hasta que se accede**: La JVM no carga clases internas estÃ¡ticas hasta que se referencian
2. **Garantiza thread-safety**: La JVM maneja la inicializaciÃ³n de campos static final de manera thread-safe
3. **Proporciona lazy loading**: INSTANCE se crea solo cuando se llama getInstance()

**[FLUJO DE EJECUCIÃ“N DETALLADO]**
1. **Primera llamada a getInstance()**:
   - JVM necesita acceder a LogManagerHolder.INSTANCE
   - JVM carga la clase LogManagerHolder
   - JVM inicializa INSTANCE = new LogManager()
   - Se retorna la instancia

2. **Llamadas posteriores**:
   - LogManagerHolder ya estÃ¡ cargada
   - INSTANCE ya existe
   - Se retorna inmediatamente

**[Â¿POR QUÃ‰ ES THREAD-SAFE?]**
La JVM garantiza que la inicializaciÃ³n de clases es thread-safe. SegÃºn la especificaciÃ³n de Java:
- Solo un thread puede inicializar una clase
- Otros threads esperan hasta que la inicializaciÃ³n termine
- Una vez inicializada, todos los threads ven el estado final

Es como tener un lock automÃ¡tico manejado por la JVM, pero sin el overhead de sincronizaciÃ³n en accesos posteriores.

**[COMPARACIÃ“N CON OTRAS IMPLEMENTACIONES]**

Vs. Eager Initialization:
- âœ… Lazy loading real
- âœ… Mismo performance despuÃ©s de creaciÃ³n
- âœ… Misma simplicidad

Vs. Synchronized Method:
- âœ… Sin overhead de sincronizaciÃ³n
- âœ… Mejor performance en alta concurrencia
- âœ… Thread-safe garantizado

Vs. Double-Checked Locking:
- âœ… Sin necesidad de volatile
- âœ… CÃ³digo mÃ¡s simple y menos propenso a errores
- âœ… Mismo performance

**[VENTAJAS COMPLETAS]**
âœ… **Thread-safe perfecto**: Garantizado por la JVM
âœ… **Lazy loading verdadero**: Carga solo cuando se necesita
âœ… **Performance Ã³ptimo**: Sin overhead despuÃ©s de creaciÃ³n
âœ… **Simplicidad**: CÃ³digo limpio y fÃ¡cil de entender
âœ… **Robustez**: DifÃ­cil de implementar incorrectamente

**[MÃNIMAS DESVENTAJAS]**
âŒ **Complejidad conceptual**: Requiere entender class loading
âŒ **Debugging**: La clase interna puede confundir en stack traces
âŒ **Incompatibilidad**: Muy raros casos con class loaders exÃ³ticos

**[CUÃNDO ES LA MEJOR OPCIÃ“N]**
- La mayorÃ­a de aplicaciones enterprise
- Cuando necesitas el mejor balance de caracterÃ­sticas
- Equipos que valoran cÃ³digo limpio y mantenible
- Sistemas de producciÃ³n donde la robustez es crÃ­tica

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 8: ENUM SINGLETON [4 minutos]
=========================================

[MOSTRAR DIAPOSITIVA 8 - Enum Singleton]

**[LA RECOMENDACIÃ“N DE JOSHUA BLOCH]**
Joshua Bloch, creador de muchas APIs de Java y autor de "Effective Java", recomienda usar Enum como la implementaciÃ³n mÃ¡s robusta de Singleton. Dice textualmente: "A single-element enum type is often the best way to implement a singleton."

**[ANÃLISIS DEL CÃ“DIGO]**
```java
public enum SessionManager {
    INSTANCE;  // â­ Este es nuestro Singleton
    
    private UserSession currentSession;
    
    public void startSession(User user) {
        currentSession = new UserSession(user);
    }
    
    public UserSession getCurrentSession() {
        return currentSession;
    }
}
```

**[Â¿CÃ“MO FUNCIONA UN ENUM COMO SINGLETON?]**
Los enums en Java tienen propiedades especiales:
1. **Instancia Ãºnica garantizada**: La JVM garantiza que solo existe UNA instancia de cada valor del enum
2. **Thread-safety automÃ¡tico**: La inicializaciÃ³n de enums es thread-safe por defecto
3. **SerializaciÃ³n segura**: Los enums se serializan de manera especial, preservando la unicidad

**[USO SÃšPER SIMPLE]**
```java
// Acceso directo al singleton
SessionManager.INSTANCE.startSession(user);
UserSession session = SessionManager.INSTANCE.getCurrentSession();
SessionManager.INSTANCE.endSession();

// TambiÃ©n se puede asignar a variable si se prefiere
SessionManager manager = SessionManager.INSTANCE;
manager.startSession(user);
```

**[PROTECCIONES AUTOMÃTICAS EXTRAORDINARIAS]**

**1. ProtecciÃ³n contra Reflection:**
```java
// âŒ Esto fallarÃ¡ con IllegalArgumentException
Constructor<SessionManager> constructor = SessionManager.class.getDeclaredConstructor();
constructor.setAccessible(true);
SessionManager fake = constructor.newInstance(); // Â¡EXCEPTION!
```

**2. ProtecciÃ³n contra SerializaciÃ³n:**
```java
// SerializaciÃ³n y deserializaciÃ³n mantienen la misma instancia
SessionManager original = SessionManager.INSTANCE;
// ... serializar y deserializar ...
SessionManager deserialized = // ... de archivo ...
assert original == deserialized; // âœ… TRUE
```

**3. ProtecciÃ³n contra ClonaciÃ³n:**
Los enums no pueden ser clonados. `clone()` automÃ¡ticamente lanza `CloneNotSupportedException`.

**[COMPARACIÃ“N DE ROBUSTEZ]**

ImplementaciÃ³n tradicional vulnerable:
```java
public class TraditionalSingleton {
    private static TraditionalSingleton instance;
    
    // âŒ Vulnerable a reflection
    private TraditionalSingleton() {}
    
    // âŒ SerializaciÃ³n puede crear nueva instancia
    // âŒ ClonaciÃ³n puede crear nueva instancia
}
```

Enum Singleton invulnerable:
```java
public enum BulletproofSingleton {
    INSTANCE;
    // âœ… Inmune a reflection
    // âœ… SerializaciÃ³n segura automÃ¡tica
    // âœ… ClonaciÃ³n imposible
}
```

**[VENTAJAS ÃšNICAS]**
âœ… **MÃ¡xima robustez**: Resistente a mÃºltiples vectores de ataque
âœ… **ConcisiÃ³n extrema**: MÃ­nimo cÃ³digo necesario
âœ… **Performance**: Tan rÃ¡pido como implementaciones tradicionales
âœ… **Thread-safety**: AutomÃ¡tico sin configuraciÃ³n

**[LIMITACIONES]**
âŒ **Herencia imposible**: Los enums no pueden extender clases
âŒ **ConfusiÃ³n inicial**: Puede ser confuso para desarrolladores nuevos
âŒ **Inflexibilidad**: No permite lazy loading controlado
âŒ **DeserializaciÃ³n**: Comportamiento especial puede sorprender

**[CUÃNDO USAR ENUM SINGLETON]**
- Sistemas crÃ­ticos donde la seguridad es paramount
- Aplicaciones que manejan serializaciÃ³n frecuente
- Cuando quieres mÃ¡xima robustez con mÃ­nimo cÃ³digo
- Sistemas que pueden ser objetivo de ataques de reflection

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 9: COMPARACIÃ“N DE IMPLEMENTACIONES [4 minutos]
==========================================================

[MOSTRAR DIAPOSITIVA 9 - Tabla comparativa]

**[ANÃLISIS SISTEMÃTICO]**
Ahora que hemos visto todas las implementaciones, analicemos sistemÃ¡ticamente cuÃ¡ndo usar cada una.

**[EAGER INITIALIZATION - AnÃ¡lisis]**
âœ… **Thread-Safe**: â­â­â­ Garantizado por JVM
âœ… **Performance**: â­â­â­ Acceso instantÃ¡neo
âŒ **Lazy Load**: âŒ Se crea aunque no se use
âœ… **Complejidad**: â­ Muy simple
**RecomendaciÃ³n**: Objetos livianos que siempre se usan

**[LAZY SIMPLE - AnÃ¡lisis]**
âŒ **Thread-Safe**: âŒ Race conditions posibles
âœ… **Performance**: â­â­â­ RÃ¡pido cuando funciona
âœ… **Lazy Load**: âœ… Verdadero lazy loading
âœ… **Complejidad**: â­ Muy simple
**RecomendaciÃ³n**: Solo aplicaciones single-thread

**[SYNCHRONIZED METHOD - AnÃ¡lisis]**
âœ… **Thread-Safe**: â­â­â­ Completamente seguro
âŒ **Performance**: â­ Overhead en cada acceso
âœ… **Lazy Load**: âœ… CreaciÃ³n bajo demanda
âœ… **Complejidad**: â­â­ Relativamente simple
**RecomendaciÃ³n**: Evitar - performance pobre

**[DOUBLE-CHECKED LOCKING - AnÃ¡lisis]**
âœ… **Thread-Safe**: â­â­â­ Con volatile correcto
âœ… **Performance**: â­â­ Bueno despuÃ©s de creaciÃ³n
âœ… **Lazy Load**: âœ… Lazy loading eficiente
âŒ **Complejidad**: â­â­â­ FÃ¡cil de implementar mal
**RecomendaciÃ³n**: Solo para expertos

**[BILL PUGH PATTERN - AnÃ¡lisis]**
âœ… **Thread-Safe**: â­â­â­ Garantizado por JVM
âœ… **Performance**: â­â­â­ Ã“ptimo en todos los aspectos
âœ… **Lazy Load**: âœ… Lazy loading elegante
âœ… **Complejidad**: â­â­ Moderado pero robusto
**RecomendaciÃ³n**: â­ PRIMERA OPCIÃ“N para la mayorÃ­a

**[ENUM SINGLETON - AnÃ¡lisis]**
âœ… **Thread-Safe**: â­â­â­ AutomÃ¡tico
âœ… **Performance**: â­â­â­ Excelente
âŒ **Lazy Load**: âŒ Eager por naturaleza
âœ… **Complejidad**: â­ Muy simple
**RecomendaciÃ³n**: MÃ¡xima seguridad requerida

**[GUÃA DE DECISIÃ“N PRÃCTICA]**

**Para desarrollo nuevo:**
1. **Primera opciÃ³n**: Bill Pugh Pattern
2. **Si necesitas mÃ¡xima seguridad**: Enum Singleton
3. **Si el objeto es liviano**: Eager Initialization

**Para sistemas legacy:**
1. **Si ya tienes Synchronized**: Migra a Bill Pugh
2. **Si tienes Double-Checked**: Revisa implementaciÃ³n o migra
3. **Si tienes Lazy Simple**: Urgente migrar a thread-safe

**Para casos especÃ­ficos:**
- **ConfiguraciÃ³n del sistema**: Bill Pugh
- **GestiÃ³n de sesiones crÃ­ticas**: Enum
- **Logger simple**: Eager
- **Cache manager**: Bill Pugh
- **Pool de conexiones**: Bill Pugh

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 10: PROBLEMAS Y ALTERNATIVAS [5 minutos]
====================================================

[MOSTRAR DIAPOSITIVA 10 - CrÃ­ticas y alternativas modernas]

**[LA CONTROVERSIA DEL SINGLETON]**
El patrÃ³n Singleton es uno de los mÃ¡s criticados en el desarrollo moderno. Entendamos por quÃ© y quÃ© alternativas tenemos.

**[PROBLEMAS FUNDAMENTALES]**

**1. Dificultad en Testing:**
```java
// âŒ DifÃ­cil de testear
public class OrderService {
    public void processOrder(Order order) {
        Logger.getInstance().log("Processing: " + order.getId());
        // Â¿CÃ³mo mockear Logger para testing?
    }
}

// Problema: No puedes inyectar un mock
// La dependencia estÃ¡ hardcodeada
```

**2. ViolaciÃ³n de Principios SOLID:**

**Single Responsibility Principle (SRP):**
```java
// âŒ MÃºltiples responsabilidades
public class DatabaseManager {
    // Responsabilidad 1: Ser singleton
    private static DatabaseManager instance;
    public static DatabaseManager getInstance() { ... }
    
    // Responsabilidad 2: Gestionar base de datos
    public void executeQuery(String sql) { ... }
    public Connection getConnection() { ... }
}
```

**Dependency Inversion Principle (DIP):**
```java
// âŒ Depende de concreciones, no abstracciones
public class UserService {
    public void saveUser(User user) {
        DatabaseManager.getInstance().save(user); // Dependencia concreta
    }
}
```

**3. Estado Global ProblemÃ¡tico:**
```java
// âŒ Estado compartido y mutable
public enum SessionManager {
    INSTANCE;
    
    private UserSession currentSession; // Â¡Estado global!
    
    public void setCurrentSession(UserSession session) {
        this.currentSession = session; // Modifica estado global
    }
}

// Problema: MÃºltiples threads pueden corromper el estado
```

**4. Acoplamiento Fuerte:**
```java
// âŒ Fuertemente acoplado
public class PaymentService {
    public void processPayment() {
        Logger.getInstance().log("Payment started");
        DatabaseManager.getInstance().save(...);
        NotificationService.getInstance().send(...);
        // Acoplado a 3 singletons - difÃ­cil de cambiar
    }
}
```

**[ALTERNATIVAS MODERNAS]**

**1. Dependency Injection - La Mejor Alternativa:**
```java
// âœ… Con Dependency Injection
public class OrderService {
    private final Logger logger;
    private final PaymentGateway gateway;
    
    // Dependencias inyectadas en constructor
    public OrderService(Logger logger, PaymentGateway gateway) {
        this.logger = logger;
        this.gateway = gateway;
    }
    
    public void processOrder(Order order) {
        logger.log("Processing: " + order.getId());
        gateway.charge(order.getAmount());
    }
}

// Testing es trivial:
@Test
public void testProcessOrder() {
    Logger mockLogger = mock(Logger.class);
    PaymentGateway mockGateway = mock(PaymentGateway.class);
    
    OrderService service = new OrderService(mockLogger, mockGateway);
    // ... test with mocks
}
```

**2. Framework DI - Spring Example:**
```java
@Service
public class OrderService {
    @Autowired
    private Logger logger;
    
    @Autowired  
    private PaymentGateway gateway;
    
    // Spring maneja el lifecycle como singleton si quieres
}

@Configuration
public class AppConfig {
    @Bean
    @Scope("singleton")  // Singleton controlado por Spring
    public Logger logger() {
        return new Logger();
    }
}
```

**3. Factory Pattern:**
```java
// âœ… Factory para control centralizado
public class ServiceFactory {
    private static Logger logger;
    
    public static Logger getLogger() {
        if (logger == null) {
            logger = new Logger();
        }
        return logger;
    }
    
    // Permite diferentes implementaciones
    public static Logger getLogger(LogLevel level) {
        return new Logger(level);
    }
}
```

**[CUÃNDO EVITAR SINGLETON]**
âŒ **Testing es crÃ­tico**: Unit testing frecuente
âŒ **Arquitectura flexible**: Necesitas cambiar implementaciones
âŒ **Microservicios**: Estado distribuido
âŒ **Frameworks DI disponibles**: Spring, CDI, Guice

**[CUÃNDO SINGLETON AÃšN ES VÃLIDO]**
âœ… **ConfiguraciÃ³n estÃ¡tica**: Properties que no cambian
âœ… **Utilidades sin estado**: Math helpers, formatters
âœ… **Performance crÃ­tico**: Overhead de DI no aceptable
âœ… **Aplicaciones legacy**: Sin framework DI disponible

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 11: CASOS REALES EMPRESARIALES [4 minutos]
======================================================

[MOSTRAR DIAPOSITIVA 11 - Implementaciones enterprise]

**[CASOS REALES EN SISTEMAS EMPRESARIALES]**
Veamos implementaciones reales donde Singleton aporta valor en sistemas enterprise.

**[CASO 1: LEGACY SYSTEM ADAPTER - ExplicaciÃ³n Detallada]**
```java
public class MainframeAdapter {
    private static volatile MainframeAdapter instance;
    
    private MainframeConnection connection;
    private ProtocolConverter converter;
    
    private MainframeAdapter() {
        // ConexiÃ³n costosa al mainframe - puede tomar 5-10 segundos
        this.connection = new MainframeConnection("tcp://mainframe.company.com:3270");
        this.converter = new ProtocolConverter();
        
        // AutenticaciÃ³n con sistema legacy
        connection.authenticate("ENTERPRISE_USER", "SYSTEM_PASSWORD");
        
        // ConfiguraciÃ³n de pooling de conexiones internas
        connection.configurePool(minConnections: 5, maxConnections: 20);
    }
    
    public static MainframeAdapter getInstance() {
        if (instance == null) {
            synchronized (MainframeAdapter.class) {
                if (instance == null) {
                    instance = new MainframeAdapter();
                }
            }
        }
        return instance;
    }
    
    public CustomerData queryCustomer(String customerId) {
        // Convierte request moderno a protocolo mainframe
        MainframeRequest request = converter.toMainframeFormat(customerId);
        
        // Ejecuta query en sistema legacy
        MainframeResponse response = connection.execute(request);
        
        // Convierte respuesta legacy a formato moderno
        return converter.toModernFormat(response);
    }
}
```

**Â¿Por quÃ© Singleton aquÃ­?**
- La conexiÃ³n al mainframe es EXTREMADAMENTE costosa
- Necesitamos una sola pool de conexiones
- El adapter es stateless - solo convierte protocolos
- Se usa desde mÃºltiples microservicios

**[CASO 2: CIRCUIT BREAKER PATTERN - Enterprise Resilience]**
```java
public enum CircuitBreakerManager {
    INSTANCE;
    
    private final Map<String, CircuitBreaker> breakers = new ConcurrentHashMap<>();
    private final ScheduledExecutorService healthChecker = Executors.newScheduledThreadPool(5);
    
    CircuitBreakerManager() {
        // Inicia health checking automÃ¡tico cada 30 segundos
        healthChecker.scheduleAtFixedRate(this::checkBreakerHealth, 30, 30, TimeUnit.SECONDS);
    }
    
    public CircuitBreaker getBreaker(String serviceName) {
        return breakers.computeIfAbsent(serviceName, this::createCircuitBreaker);
    }
    
    private CircuitBreaker createCircuitBreaker(String serviceName) {
        return CircuitBreaker.builder()
            .failureThreshold(5)           // 5 fallos consecutivos
            .timeout(Duration.ofSeconds(10)) // 10 segundos timeout
            .retryAfter(Duration.ofMinutes(2)) // reintentar despuÃ©s de 2 minutos
            .onStateChange(this::logStateChange)
            .build();
    }
    
    public <T> T executeWithBreaker(String serviceName, Supplier<T> operation) {
        CircuitBreaker breaker = getBreaker(serviceName);
        return breaker.execute(operation);
    }
    
    private void checkBreakerHealth() {
        breakers.forEach((service, breaker) -> {
            if (breaker.getState() == HALF_OPEN) {
                // Intenta operaciÃ³n de health check
                try {
                    healthCheckService(service);
                    breaker.onSuccess(); // Marca como saludable
                } catch (Exception e) {
                    breaker.onFailure(); // Mantiene circuito abierto
                }
            }
        });
    }
}

// Uso en servicios:
@RestController
public class PaymentController {
    
    @PostMapping("/payment")
    public ResponseEntity<PaymentResult> processPayment(@RequestBody PaymentRequest request) {
        try {
            PaymentResult result = CircuitBreakerManager.INSTANCE.executeWithBreaker(
                "payment-gateway",
                () -> paymentGateway.processPayment(request)
            );
            return ResponseEntity.ok(result);
        } catch (CircuitBreakerOpenException e) {
            // Servicio no disponible, usar fallback
            return ResponseEntity.status(503)
                .body(PaymentResult.failed("Service temporarily unavailable"));
        }
    }
}
```

**Â¿Por quÃ© Singleton aquÃ­?**
- Necesitamos vista global del estado de todos los servicios
- Los circuit breakers deben ser compartidos entre requests
- El health checking debe ser centralizado
- Estado debe persistir durante toda la vida de la aplicaciÃ³n

**[CASO 3: NOTIFICATION TEMPLATE MANAGER - Multi-channel]**
```java
public class NotificationTemplateManager {
    private static final NotificationTemplateManager INSTANCE = new NotificationTemplateManager();
    
    private final Map<String, MessageTemplate> templates;
    private final List<NotificationChannel> channels;
    
    private NotificationTemplateManager() {
        // Cargar plantillas desde configuraciÃ³n
        this.templates = loadTemplatesFromConfig();
        
        // Inicializar canales de notificaciÃ³n
        this.channels = Arrays.asList(
            new EmailChannel(smtpConfig),
            new SmsChannel(twilioConfig), 
            new PushChannel(firebaseConfig),
            new SlackChannel(slackConfig)
        );
    }
    
    public static NotificationTemplateManager getInstance() {
        return INSTANCE;
    }
    
    public void sendNotification(String templateId, Map<String, Object> data, NotificationType... types) {
        MessageTemplate template = templates.get(templateId);
        if (template == null) {
            throw new IllegalArgumentException("Template not found: " + templateId);
        }
        
        for (NotificationType type : types) {
            NotificationChannel channel = getChannelForType(type);
            
            // Renderizar template con datos
            String message = template.render(data);
            
            // Enviar de manera asÃ­ncrona
            CompletableFuture.runAsync(() -> {
                try {
                    channel.send(message, data);
                    logNotificationSent(templateId, type, data);
                } catch (Exception e) {
                    logNotificationFailed(templateId, type, data, e);
                    // Implementar retry logic si es necesario
                }
            });
        }
    }
}

// Uso:
public class OrderService {
    public void completeOrder(Order order) {
        // ... lÃ³gica de negocio ...
        
        // Notificar al cliente por mÃºltiples canales
        Map<String, Object> data = Map.of(
            "customerName", order.getCustomerName(),
            "orderId", order.getId(),
            "totalAmount", order.getTotalAmount(),
            "deliveryDate", order.getEstimatedDelivery()
        );
        
        NotificationTemplateManager.getInstance().sendNotification(
            "order-completion",
            data,
            EMAIL, PUSH, SMS
        );
    }
}
```

**[BENEFICIOS EN ENTERPRISE]**
âœ… **ConfiguraciÃ³n Ãºnica**: Una sola fuente de configuraciÃ³n
âœ… **Resource pooling**: Conexiones caras reutilizadas eficientemente
âœ… **Caching central**: Cache compartido entre componentes
âœ… **Monitoring unificado**: MÃ©tricas y logs centralizados
âœ… **State management**: Estado compartido cuando es apropiado

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 12: BEST PRACTICES [4 minutos]
==========================================

[MOSTRAR DIAPOSITIVA 12 - Mejores prÃ¡cticas]

**[GUÃA COMPLETA DE IMPLEMENTACIÃ“N]**
DespuÃ©s de analizar todas las variantes, aquÃ­ estÃ¡n las mejores prÃ¡cticas definitivas.

**[PATRÃ“N RECOMENDADO: BILL PUGH]**
Para el 90% de casos, usa Bill Pugh Pattern:

```java
public class ConfigurationManager {
    // Constructor privado - FUNDAMENTAL
    private ConfigurationManager() {
        // Cargar configuraciÃ³n, inicializar recursos
        loadConfiguration();
    }
    
    // Clase interna estÃ¡tica - CLAVE del patrÃ³n
    private static class ConfigurationHolder {
        private static final ConfigurationManager INSTANCE = new ConfigurationManager();
    }
    
    // MÃ©todo de acceso pÃºblico
    public static ConfigurationManager getInstance() {
        return ConfigurationHolder.INSTANCE;
    }
    
    // MÃ©todos de negocio...
    public String getProperty(String key) { ... }
}
```

**[VALIDACIONES ANTES DE IMPLEMENTAR]**
Antes de crear cualquier Singleton, hazte estas preguntas crÃ­ticas:

**1. Â¿Realmente necesitas UNA SOLA instancia?**
```java
// âŒ Mal uso - no necesita ser Ãºnico
public class MathUtils {
    public static MathUtils getInstance() { ... }
    public int add(int a, int b) { return a + b; }
}

// âœ… Mejor opciÃ³n - mÃ©todos estÃ¡ticos
public class MathUtils {
    private MathUtils() {} // Evitar instanciaciÃ³n
    public static int add(int a, int b) { return a + b; }
}
```

**2. Â¿Puede ser reemplazado por Dependency Injection?**
```java
// âŒ Singleton problemÃ¡tico
public class DatabaseService {
    public static DatabaseService getInstance() { ... }
    public void save(Entity entity) { ... }
}

public class UserService {
    public void saveUser(User user) {
        DatabaseService.getInstance().save(user); // Acoplamiento fuerte
    }
}

// âœ… Con DI - mÃ¡s testeable y flexible
public class UserService {
    private final DatabaseService databaseService;
    
    public UserService(DatabaseService databaseService) {
        this.databaseService = databaseService;
    }
    
    public void saveUser(User user) {
        databaseService.save(user); // Inyectado, mockeable
    }
}
```

**3. Â¿Es testeable fÃ¡cilmente?**
```java
// âœ… Singleton testeable
public class ConfigurationManager {
    // ... implementaciÃ³n normal ...
    
    // MÃ©todo SOLO para testing
    static void resetForTesting() {
        // Solo disponible en test classpath
        if (!isRunningInTest()) {
            throw new IllegalStateException("Only for testing");
        }
        // Reset logic...
    }
}
```

**[CHECKLIST DE CALIDAD COMPLETO]**

**âœ… ImplementaciÃ³n correcta:**
- [ ] Constructor privado
- [ ] Thread-safe (Bill Pugh, Enum, o Eager)
- [ ] Lazy loading cuando es apropiado
- [ ] Manejo de excepciones en constructor
- [ ] Serialization-safe si es necesario

**âœ… DiseÃ±o sÃ³lido:**
- [ ] Una sola responsabilidad
- [ ] Stateless o estado inmutable preferiblemente
- [ ] No depende de otros Singletons
- [ ] Interfaz limpia y mÃ­nima

**âœ… Testing y mantenimiento:**
- [ ] Unit tests posibles
- [ ] MÃ©todos para testing si es necesario
- [ ] DocumentaciÃ³n clara del por quÃ© es Singleton
- [ ] Plan de migraciÃ³n a DI si es apropiado

**[ANTIPATRONES A EVITAR ABSOLUTAMENTE]**

**âŒ God Object Singleton:**
```java
// âŒ Hace demasiadas cosas
public class SystemManager {
    public void configureDatabase() { ... }
    public void sendEmail() { ... }
    public void processPayment() { ... }
    public void generateReport() { ... }
    // ViolaciÃ³n masiva de SRP
}
```

**âŒ Singleton Dependency Chain:**
```java
// âŒ Singletons que dependen de otros Singletons
public class ServiceA {
    public void doSomething() {
        ServiceB.getInstance().callMethod();
        ServiceC.getInstance().anotherMethod();
    }
}
```

**âŒ Global State Abuse:**
```java
// âŒ Estado mutable global
public enum UserContext {
    INSTANCE;
    
    private User currentUser; // Â¡ProblemÃ¡tico!
    
    public void setCurrentUser(User user) { 
        this.currentUser = user; // Estado global mutable
    }
}
```

**[RECOMENDACIÃ“N FINAL]**
El Singleton es una herramienta poderosa cuando se usa correctamente. La regla de oro:

**"Usa Singleton solo cuando NECESITES exactamente una instancia Y cuando las alternativas (como DI) no sean apropiadas para tu contexto especÃ­fico."**

Para desarrollo moderno, considera Spring Framework o CDI que proporcionan lifecycle management sin los problemas del Singleton tradicional.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DIAPOSITIVA 13: CONCLUSIONES [3 minutos]
========================================

[MOSTRAR DIAPOSITIVA 13 - Conclusiones finales]

**[RESUMEN EJECUTIVO]**
Hemos recorrido un viaje completo por el patrÃ³n Singleton, desde sus fundamentos hasta implementaciones avanzadas y alternativas modernas.

**[LO QUE HEMOS APRENDIDO]**
âœ… **6 implementaciones diferentes**: Cada una con sus trade-offs especÃ­ficos
âœ… **Thread-safety crÃ­tico**: En aplicaciones modernas, esto no es opcional
âœ… **Trade-offs claros**: Performance vs Simplicidad, Seguridad vs Flexibilidad
âœ… **Casos reales**: Aplicaciones concretas en sistemas enterprise

**[DECISIONES DE IMPLEMENTACIÃ“N]**
Para recapitular nuestras recomendaciones:

ğŸ¥‡ **Bill Pugh Pattern**: Tu primera opciÃ³n para la mayorÃ­a de casos
- Lazy loading + Thread-safe + Performance Ã³ptimo

ğŸ¥ˆ **Enum Singleton**: Cuando necesitas mÃ¡xima seguridad
- ProtecciÃ³n automÃ¡tica contra mÃºltiples vectores de ataque

ğŸ¥‰ **Eager Initialization**: Para objetos simples y livianos
- Cuando lazy loading no aporta valor

**[EVOLUCIÃ“N DEL PATRÃ“N]**
El Singleton no existe en el vacÃ­o. En el contexto actual:

ğŸ”® **Microservicios**: El estado global es mÃ¡s complejo
ğŸ”® **Cloud-native**: Los containers manejan el lifecycle
ğŸ”® **Frameworks modernos**: DI frameworks proporcionan alternativas
ğŸ”® **Observabilidad**: Monitoreo distribuido cambia los requirements

**[MENSAJES CLAVE PARA LLEVAR]**

1. **Singleton es una herramienta, no una soluciÃ³n universal**
   - Ãšsalo solo cuando realmente necesites UNA instancia
   - Considera las alternativas antes de implementar

2. **El balance es crucial en software**
   - Thread-safety vs Performance
   - Simplicidad vs Flexibilidad
   - Control vs Acoplamiento

3. **Las alternativas modernas son poderosas**
   - Dependency Injection frameworks
   - Container-managed beans
   - Service registries

4. **El contexto determina la decisiÃ³n**
   - Aplicaciones legacy vs modernas
   - Performance crÃ­tico vs flexibilidad
   - Recursos limitados vs escalabilidad

**[REFLEXIONES FINALES]**
El Singleton seguirÃ¡ siendo relevante, pero su uso debe ser mÃ¡s thoughtful y contextual. En el desarrollo moderno, pregÃºntate siempre: "Â¿Hay una manera mÃ¡s flexible de lograr esto?"

**[PREGUNTAS PARA CONTINUAR APRENDIENDO]**
- Â¿CÃ³mo se comporta Singleton en arquitecturas distribuidas?
- Â¿QuÃ© patrones complementan o reemplazan a Singleton?
- Â¿CÃ³mo afectan los contenedores Docker al lifecycle de Singletons?
- Â¿QuÃ© consideraciones adicionales tiene Singleton en aplicaciones reactivas?

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SESIÃ“N DE PREGUNTAS Y RESPUESTAS [8-10 minutos]
===============================================

**[PREPARACIÃ“N PARA PREGUNTAS COMUNES]**

**P: "Â¿CuÃ¡ndo NO deberÃ­a usar Singleton?"**
R: Evita Singleton cuando el testing es crÃ­tico, cuando necesitas flexibilidad para cambiar implementaciones, cuando usas frameworks DI, o cuando el "objeto Ãºnico" es realmente un concepto de dominio que podrÃ­a cambiar.

**P: "Â¿CÃ³mo manejo las excepciones en el constructor?"**
R: Depende de la implementaciÃ³n. En Eager, la excepciÃ³n previene que la clase se cargue. En lazy implementations, puedes catch y relanzar, o permitir que la excepciÃ³n bubble up y reintentar en la siguiente llamada.

**P: "Â¿Singleton es compatible con microservicios?"**
R: Singleton dentro de un microservicio puede ser apropiado, pero evita estado compartido entre servicios. Considera service registries o configuration services para datos compartidos.

**P: "Â¿CÃ³mo testeo cÃ³digo que usa Singleton?"**
R: Opciones: 1) Proporcionar mÃ©todos reset para testing, 2) Usar DI en lugar de Singleton, 3) Mockear a nivel de sistema, 4) Aislar la funcionalidad del Singleton detrÃ¡s de interfaces.

Â¡Gracias por su atenciÃ³n! Â¿Preguntas?

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NOTAS ADICIONALES PARA EL EXPOSITOR:
===================================

**Timing sugerido:**
- IntroducciÃ³n: 2 min
- Diapositivas 1-3: 9 min (3 min c/u)
- Diapositivas 4-6: 13 min (4-5 min c/u)
- Diapositivas 7-8: 9 min (4-5 min c/u)
- Diapositivas 9-11: 12 min (4 min c/u)
- Diapositivas 12-13: 7 min (3-4 min c/u)
- Q&A: 8-10 min

**Consejos de presentaciÃ³n:**
- Usa ejemplos de cÃ³digo en vivo si es posible
- Enfatiza los problemas de concurrencia con diagramas
- Relaciona cada implementaciÃ³n con casos reales
- MantÃ©n la energÃ­a alta durante las partes tÃ©cnicas
- Invita preguntas durante la presentaciÃ³n, no solo al final

**Material de apoyo sugerido:**
- Diagramas de threads en whiteboard
- CÃ³digo de ejemplo funcionando
- MÃ©tricas de performance si estÃ¡n disponibles
- Referencias a documentaciÃ³n oficial de Java

- **Cache manager**: Una sola instancia de cache evita duplicaciÃ³n de datos en memoria.

**Casos donde NO usar Singleton:**

- Cuando necesitamos mÃºltiples instancias (obviamente)
- En testing, porque dificulta los unit tests al crear dependencias globales
- En sistemas concurrentes complejos donde puede convertirse en un cuello de botella
- Cuando viola los principios SOLID, especialmente el de responsabilidad Ãºnica

Recuerden: el Singleton debe usarse con moderaciÃ³n. No todo debe ser singleton solo porque "es mÃ¡s fÃ¡cil acceder globalmente".

DIAPOSITIVA 3: EAGER INITIALIZATION (3 minutos)
===============================================

[MOSTRAR DIAPOSITIVA 3]

Ahora vamos a ver las diferentes implementaciones. Empezamos con la mÃ¡s simple: Eager Initialization.

[LEER Y EXPLICAR EL CÃ“DIGO]

```java
public class ConfigurationManager {
    // Instancia creada al cargar la clase
    private static final ConfigurationManager INSTANCE = new ConfigurationManager();
    
    private Properties config;
    
    private ConfigurationManager() {
        // Constructor privado
        loadConfiguration();
    }
    
    public static ConfigurationManager getInstance() {
        return INSTANCE;
    }
}
```

**ExplicaciÃ³n del cÃ³digo:**

1. **LÃ­nea 3**: `private static final ConfigurationManager INSTANCE` - La palabra clave `static` significa que la variable pertenece a la clase, no a una instancia especÃ­fica. `final` asegura que no puede ser reasignada. La instancia se crea inmediatamente cuando la JVM carga la clase.

2. **LÃ­nea 7**: Constructor privado - Esto es CRÃTICO. Al hacer privado el constructor, impedimos que otras clases creen instancias usando `new ConfigurationManager()`.

3. **LÃ­nea 12**: El mÃ©todo `getInstance()` es pÃºblico y estÃ¡tico, permitiendo acceso global sin necesidad de tener una instancia.

En el contexto de sistemas empresariales, este ConfigurationManager cargarÃ­a las configuraciones de conexiÃ³n a los sistemas como bases de datos y APIs externas.

**Ventajas:**
- Thread-safe por naturaleza (la JVM garantiza que static final se inicializa una sola vez)
- Simple de implementar
- No hay overhead de sincronizaciÃ³n

**Desventajas:**
- No es lazy - se crea aunque nunca se use
- Si el constructor lanza excepciones, no las podemos manejar elegantemente

DIAPOSITIVA 4: LAZY INITIALIZATION (3 minutos)
==============================================

[MOSTRAR DIAPOSITIVA 4]

Ahora veamos Lazy Initialization - creaciÃ³n bajo demanda.

[LEER Y EXPLICAR EL CÃ“DIGO]

```java
public class AuditLogger {
    private static AuditLogger instance;
    private List<AuditEvent> auditEvents;
    
    private AuditLogger() {
        auditEvents = new ArrayList<>();
    }
    
    public static AuditLogger getInstance() {
        if (instance == null) {
            instance = new AuditLogger();
        }
        return instance;
    }
}
```

**ExplicaciÃ³n detallada:**

1. **LÃ­nea 2**: `private static AuditLogger instance;` - Note que aquÃ­ NO inicializamos la instancia inmediatamente. Se declara pero permanece null hasta que se necesite.

2. **LÃ­neas 9-12**: El mÃ©todo `getInstance()` implementa la lÃ³gica de creaciÃ³n lazy. Primero verifica si la instancia existe (`if (instance == null)`), y solo si no existe, la crea.

3. **AuditLogger**: En sistemas empresariales, este logger registrarÃ­a todas las acciones de auditorÃ­a: quiÃ©n accediÃ³ a quÃ© informaciÃ³n, cuÃ¡ndo se realizaron transacciones, cambios en los datos, etc.

El mÃ©todo `logEvent()` crearÃ­a eventos como:
- Usuario "juan.perez" consultÃ³ saldo de energÃ­a a las 14:30
- Usuario "maria.gomez" realizÃ³ pago de $150,000 para servicios mÃºltiples
- Admin "admin.sistema" modificÃ³ configuraciÃ³n de tarifas

**PROBLEMA CRÃTICO:**

Esta implementaciÃ³n tiene un problema grave en aplicaciones multi-hilo. Si dos hilos ejecutan `getInstance()` simultÃ¡neamente cuando `instance` es null, ambos pueden pasar la verificaciÃ³n `if (instance == null)` y crear dos instancias diferentes.

Esto viola completamente el principio del Singleton. Por eso esta implementaciÃ³n solo debe usarse en aplicaciones single-thread.

DIAPOSITIVA 5: SYNCHRONIZED METHOD (3 minutos)
==============================================

[MOSTRAR DIAPOSITIVA 5]

Para solucionar el problema de concurrencia, podemos sincronizar el mÃ©todo completo.

[EXPLICAR EL CÃ“DIGO]

```java
public static synchronized ConnectionPoolManager getInstance() {
    if (instance == null) {
        instance = new ConnectionPoolManager();
    }
    return instance;
}
```

**ExplicaciÃ³n de sincronizaciÃ³n:**

La palabra clave `synchronized` en un mÃ©todo estÃ¡tico significa que solo un hilo puede ejecutar este mÃ©todo a la vez. Java usa el objeto Class como monitor de sincronizaciÃ³n.

**ConnectionPoolManager en Sistemas Empresariales:**

Este singleton gestiona pools de conexiones para:

1. **Mainframe Pool**: Conexiones al sistema IBM Z/OS donde estÃ¡n los datos histÃ³ricos de energÃ­a y acueducto
2. **Oracle Pool**: Conexiones a las bases de datos Oracle en Solaris donde se manejan las cuentas corrientes

**ConfiguraciÃ³n explicada:**

```java
// ConfiguraciÃ³n pool Mainframe
HikariConfig mainframeConfig = new HikariConfig();
        mainframeConfig.setJdbcUrl("jdbc:db2://database.company.com:50000/ENTERPRISE");
mainframeConfig.setMaximumPoolSize(10);
```

- **HikariCP**: Es una librerÃ­a de pool de conexiones muy eficiente
- **jdbc:db2**: Driver para conectar a bases de datos DB2 del mainframe
- **MaximumPoolSize(10)**: MÃ¡ximo 10 conexiones simultÃ¡neas al mainframe

Â¿Por quÃ© un pool? Crear una conexiÃ³n a base de datos es costoso (puede tomar 100-500ms). Con un pool, mantenemos conexiones abiertas y las reutilizamos.

**Problema de performance:**

Aunque es thread-safe, sincronizar todo el mÃ©todo significa que incluso despuÃ©s de que la instancia estÃ© creada, todos los accesos posteriores deben esperar el lock. Esto es ineficiente.

DIAPOSITIVA 6: DOUBLE-CHECKED LOCKING (4 minutos)
=================================================

[MOSTRAR DIAPOSITIVA 6]

Para optimizar la performance, usamos Double-Checked Locking.

[EXPLICAR EL CÃ“DIGO LÃNEA POR LÃNEA]

```java
public static CacheManager getInstance() {
    if (instance == null) {                    // Primera verificaciÃ³n (sin lock)
        synchronized (CacheManager.class) {
            if (instance == null) {            // Segunda verificaciÃ³n (con lock)
                instance = new CacheManager();
            }
        }
    }
    return instance;
}
```

**ExplicaciÃ³n del patrÃ³n:**

1. **Primera verificaciÃ³n** (lÃ­nea 2): Sin sincronizaciÃ³n, verificamos si la instancia ya existe. Si existe, retornamos inmediatamente sin entrar al bloque sincronizado.

2. **Bloque sincronizado** (lÃ­nea 3): Solo si la instancia es null, entramos al bloque sincronizado.

3. **Segunda verificaciÃ³n** (lÃ­nea 4): Dentro del bloque sincronizado, verificamos nuevamente porque otro hilo pudo haber creado la instancia mientras esperÃ¡bamos el lock.

**CRÃTICO - volatile:**

```java
private static volatile CacheManager instance;
```

La palabra clave `volatile` es ESENCIAL. Sin ella, las optimizaciones del compilador y CPU pueden causar que un hilo vea una instancia "parcialmente construida". volatile garantiza:
- Visibilidad: cambios en un hilo son inmediatamente visibles a otros hilos
- Orden: prohÃ­be reordenamiento de instrucciones

**CacheManager en Sistemas Empresariales:**

Este gestor implementa un cache de dos niveles:

1. **L1 (Local Cache)**: Caffeine cache en memoria local para acceso ultra-rÃ¡pido
2. **L2 (Distributed Cache)**: Redis para compartir cache entre mÃºltiples instancias del microservicio

**Ejemplo de uso:**
- Usuario consulta saldo â†’ Se cachea en L1 y L2
- PrÃ³xima consulta del mismo usuario â†’ Se responde desde L1 (microsegundos)
- Consulta desde otra instancia del servicio â†’ Se responde desde L2 (milisegundos)
- Sin cache â†’ Consulta al mainframe (segundos)

DIAPOSITIVA 7: BILL PUGH PATTERN (3 minutos)
============================================

[MOSTRAR DIAPOSITIVA 7]

El patrÃ³n Bill Pugh es considerado la mejor prÃ¡ctica para Singleton lazy.

[EXPLICAR EL CÃ“DIGO]

```java
private static class CircuitBreakerHolder {
    private static final CircuitBreakerManager INSTANCE = new CircuitBreakerManager();
}

public static CircuitBreakerManager getInstance() {
    return CircuitBreakerHolder.INSTANCE;
}
```

**Â¿CÃ³mo funciona la magia?**

1. **Clase interna estÃ¡tica**: `CircuitBreakerHolder` es una clase nested static
2. **Lazy loading por JVM**: La JVM no carga clases internas hasta que son referenciadas
3. **Thread-safety garantizado**: La JVM garantiza que la inicializaciÃ³n de static final es thread-safe
4. **Sin overhead**: No hay sincronizaciÃ³n explÃ­cita, todo lo maneja la JVM

**CircuitBreakerManager explicado:**

Un Circuit Breaker es un patrÃ³n que previene cascadas de fallos. En sistemas empresariales:

```java
CircuitBreakerConfig mainframeConfig = CircuitBreakerConfig.custom()
    .failureRateThreshold(60)                    // 60% fallos
    .waitDurationInOpenState(Duration.ofSeconds(60))  // 60s abierto
    .slidingWindowSize(10)                       // ventana 10 requests
    .minimumNumberOfCalls(5)                     // mÃ­nimo 5 calls
    .build();
```

**Estados del Circuit Breaker:**

1. **CLOSED**: Normal, permite todas las llamadas
2. **OPEN**: Demasiados fallos, bloquea todas las llamadas por 60 segundos
3. **HALF-OPEN**: DespuÃ©s de 60s, permite algunas llamadas de prueba

**Escenario real**: Si el mainframe falla, en lugar de que todos los microservicios colapsen intentando conectarse repetidamente, el circuit breaker los protege, retornando un error inmediato y permitiendo que el sistema siga funcionando parcialmente.

DIAPOSITIVA 8: ENUM SINGLETON (4 minutos)
=========================================

[MOSTRAR DIAPOSITIVA 8]

El Enum Singleton es considerado la implementaciÃ³n mÃ¡s robusta.

[EXPLICAR EL CÃ“DIGO]

```java
public enum NotificationService {
    INSTANCE;
    
    // Constructor ejecutado una sola vez
    NotificationService() {
        initializeServices();
    }
    
    public static NotificationService getInstance() {
        return INSTANCE;
    }
}
```

**Â¿Por quÃ© Enum es especial?**

1. **Thread-safety**: Los enums son thread-safe por naturaleza
2. **SerializaciÃ³n segura**: La JVM garantiza que despuÃ©s de deserializar, tendremos la misma instancia
3. **ProtecciÃ³n contra Reflection**: No se puede usar reflection para crear nuevas instancias
4. **ProtecciÃ³n contra clonaciÃ³n**: Los enums no se pueden clonar

**NotificationService en Sistemas Empresariales:**

Este servicio maneja notificaciones multicanal:

```java
private void initializeServices() {
    // ConfiguraciÃ³n servicio email
    emailService = EmailService.builder()
        .smtpHost("smtp.company.com")
        .smtpPort(587)
        .username("noreply@company.com")
        .password(System.getenv("SMTP_PASSWORD"))
        .build();
}
```

**ExplicaciÃ³n de configuraciones:**

- **SMTP**: Simple Mail Transfer Protocol para envÃ­o de emails
- **Puerto 587**: Puerto estÃ¡ndar para SMTP con TLS (encriptaciÃ³n)
- **System.getenv()**: Lee variables de entorno, mÃ¡s seguro que hardcodear passwords

**Ejemplo de notificaciÃ³n multicanal:**

```java
public void sendNotification(NotificationRequest request) {
    switch (request.getChannel()) {
        case ALL:
            sendMultiChannel(request);
            break;
    }
}

private void sendMultiChannel(NotificationRequest request) {
    CompletableFuture.allOf(
        CompletableFuture.runAsync(() -> emailService.send(...)),
        CompletableFuture.runAsync(() -> smsService.send(...)),
        CompletableFuture.runAsync(() -> pushService.send(...))
    );
}
```

**CompletableFuture explicado:**

- **AsÃ­ncrono**: Los tres servicios (email, SMS, push) se ejecutan en paralelo
- **allOf()**: Espera a que todos terminen
- **runAsync()**: Ejecuta cada tarea en un hilo separado

**Escenario real**: Cuando un usuario paga sus servicios, se envÃ­a simultÃ¡neamente:
- Email con recibo detallado
- SMS con confirmaciÃ³n
- Push notification a la app mÃ³vil

DIAPOSITIVA 9: COMPARACIÃ“N (2 minutos)
======================================

[MOSTRAR TABLA COMPARATIVA]

Vamos a resumir cuÃ¡ndo usar cada implementaciÃ³n:

**Eager Initialization**: 
- Ãšsenlo para objetos livianos que siempre van a necesitar
- Como configuraciones bÃ¡sicas del sistema

**Lazy Simple**: 
- Solo en aplicaciones single-thread
- PrÃ¡cticamente nunca en aplicaciones modernas

**Synchronized Method**: 
- EvÃ­tenlo, el overhead es demasiado grande

**Double-Checked Locking**: 
- Solo en casos muy especÃ­ficos donde necesiten optimizaciÃ³n extrema
- Requiere entender muy bien concurrencia

**Bill Pugh**: 
- **RECOMENDADO** para la mayorÃ­a de casos
- Combina lazy loading, thread-safety y performance

**Enum**: 
- **MÃS SEGURO** cuando necesiten mÃ¡xima robustez
- Especialmente para servicios crÃ­ticos

DIAPOSITIVA 10: PROBLEMAS Y ALTERNATIVAS (3 minutos)
====================================================

[MOSTRAR DIAPOSITIVA 10]

El Singleton tiene problemas serios en aplicaciones modernas:

**1. Dificultad en Testing:**

```java
// âŒ ProblemÃ¡tico
@Test
public void testPaymentProcessing() {
    ConnectionPoolManager poolManager = ConnectionPoolManager.getInstance();
    // No podemos mockear fÃ¡cilmente
}
```

El problema: en unit tests queremos aislar la funcionalidad. Si nuestro cÃ³digo depende de un singleton real, no podemos reemplazarlo con un mock para testing.

**âœ… SoluciÃ³n moderna - Dependency Injection:**

```java
@Service
public class PaymentService {
    private final ConnectionPoolManager poolManager;
    
    // InyecciÃ³n por constructor
    public PaymentService(ConnectionPoolManager poolManager) {
        this.poolManager = poolManager;
    }
}
```

Con Spring Framework:
- La instancia es singleton por defecto
- Pero podemos inyectar mocks en testing
- Mejor testabilidad y flexibilidad

**2. ViolaciÃ³n de Responsabilidad Ãšnica:**
- El singleton gestiona su propia creaciÃ³n Y su lÃ³gica de negocio
- DeberÃ­a hacer solo una cosa

**3. Acoplamiento Fuerte:**
- Las clases quedan acopladas directamente al singleton
- DifÃ­cil cambiar implementaciones

**Alternativa Spring:**

```java
@Component
@Scope("singleton")  // Singleton por defecto
public class CacheManager {
    // Spring gestiona el ciclo de vida
}
```

Spring maneja la creaciÃ³n, inyecciÃ³n y ciclo de vida, dÃ¡ndonos los beneficios del singleton sin los problemas.

DIAPOSITIVA 11: CASOS REALES EN SISTEMAS EMPRESARIALES (3 minutos)
=======================================================

[MOSTRAR DIAPOSITIVA 11]

Veamos implementaciones reales en nuestro proyecto:

**1. Legacy Adapter Factory:**

```java
public enum LegacyAdapterFactory {
    INSTANCE;
    
    private final Map<TipoSistema, LegacySystemAdapter> adapters;
    
    public LegacySystemAdapter getAdapter(TipoSistema tipo) {
        return adapters.get(tipo);
    }
}
```

**Â¿Por quÃ© usar Factory como singleton?**

En sistemas empresariales modernos tenemos tres tipos de sistemas diferentes:
- **Mainframe IBM**: Datos histÃ³ricos de energÃ­a (COBOL/DB2)
- **Oracle Solaris**: Cuentas corrientes de acueducto (PL/SQL)
- **API REST**: Sistema de telecomunicaciones (moderno)

Cada uno requiere un adaptador diferente para traducir formatos. El factory singleton asegura que:
- Solo hay una instancia de cada adaptador
- Acceso rÃ¡pido sin recrear objetos
- ConfiguraciÃ³n centralizada

**2. Message Translator:**

```java
public String translateFromEBCDIC(byte[] ebcdicData) {
    // EBCDIC â†’ JSON translation
    return formatters.get("EBCDIC").parse(ebcdicData);
}

public String translateToPLSQL(JsonNode jsonData) {
    // JSON â†’ PL/SQL translation
    return formatters.get("PLSQL").format(jsonData);
}
```

**EBCDIC explicado:**
- Extended Binary Coded Decimal Interchange Code
- CodificaciÃ³n de caracteres usada en mainframes IBM
- Diferente a ASCII/UTF-8 que usamos normalmente
- Necesitamos traducir datos del mainframe a JSON moderno

**Flujo real de datos:**
1. Microservicio recibe peticiÃ³n de saldo
2. Usa MessageTranslator para convertir JSON â†’ EBCDIC
3. EnvÃ­a al mainframe
4. Recibe respuesta en EBCDIC
5. Usa MessageTranslator para convertir EBCDIC â†’ JSON
6. Retorna al cliente

DIAPOSITIVA 12: BEST PRACTICES (2 minutos)
==========================================

[MOSTRAR DIAPOSITIVA 12]

**Buenas prÃ¡cticas esenciales:**

1. **Prefiere Enum Singleton** para casos simples donde necesites mÃ¡xima robustez

2. **Usa Bill Pugh** cuando tengas lÃ³gica compleja de inicializaciÃ³n

3. **Implementa Serializable correctamente:**

```java
// ProtecciÃ³n contra serializaciÃ³n
private Object readResolve() {
    return INSTANCE;
}
```

Esto asegura que despuÃ©s de deserializar, obtenemos la misma instancia singleton.

4. **Protege contra Reflection:**

```java
private SingletonClass() {
    if (INSTANCE != null) {
        throw new RuntimeException("Use getInstance() method");
    }
}
```

5. **Protege contra clonaciÃ³n:**

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException("Singleton cannot be cloned");
}
```

**Anti-patrones a evitar:**

- No uses lazy loading sin thread-safety
- Evita synchronized methods (usa Bill Pugh o enum)
- No hagas singleton todo lo que "parece" global
- No ignores el testing

DIAPOSITIVA 13: CONCLUSIONES (2 minutos)
========================================

[MOSTRAR DIAPOSITIVA 13]

**Resumen final:**

El patrÃ³n Singleton debe usarse con moderaciÃ³n y sabidurÃ­a:

**âœ… Usar cuando necesites:**
- Exactamente una instancia (configuraciÃ³n, pools, caches)
- Control de acceso a recursos caros
- Estado global bien justificado

**âŒ Evitar cuando:**
- Complique el testing
- Viole principios SOLID
- Puedas usar dependency injection

**RecomendaciÃ³n para aplicaciones modernas:**

```
Spring/CDI â†’ Dependency Injection (preferido)
Casos legacy especÃ­ficos â†’ Enum Singleton  
Recursos compartidos simples â†’ Bill Pugh
```

**El futuro del Singleton:**

En arquitecturas modernas:
- **Microservicios**: Cada servicio es conceptualmente singleton
- **Cloud Native**: Preferimos stateless sobre stateful singletons
- **Containers**: Kubernetes/Docker gestionan instancias Ãºnicas

**Para Sistemas Empresariales:**
- Usamos singletons para componentes de infraestructura (adapters, translators)
- Dependency injection para lÃ³gica de negocio
- Enum singletons para mÃ¡xima robustez en componentes crÃ­ticos

PREGUNTAS Y RESPUESTAS (5 minutos)
=================================

Ahora estoy abierto a responder cualquier pregunta sobre:

- Implementaciones especÃ­ficas del patrÃ³n Singleton
- Aplicaciones en sistemas empresariales
- Comparaciones entre diferentes enfoques
- Alternativas modernas como dependency injection
- Casos de uso especÃ­ficos en sistemas legacy

Â¡Muchas gracias por su atenciÃ³n!

===============================================================================
NOTAS ADICIONALES PARA EL EXPOSITOR:
===============================================================================

TIMING SUGERIDO:
- IntroducciÃ³n: 2-3 minutos
- Diapositivas 1-2: 4 minutos  
- Diapositivas 3-5: 9 minutos (implementaciones bÃ¡sicas)
- Diapositivas 6-8: 10 minutos (implementaciones avanzadas)
- Diapositivas 9-10: 5 minutos (comparaciÃ³n y problemas)
- Diapositivas 11-13: 7 minutos (casos reales y conclusiones)
- Preguntas: 5 minutos
- TOTAL: 40-45 minutos

TIPS DE PRESENTACIÃ“N:
- Enfatiza los problemas de concurrencia con ejemplos
- Usa analogÃ­as del mundo real para explicar conceptos tÃ©cnicos
- Conecta siempre con ejemplos de sistemas empresariales para hacer relevante
- PrepÃ¡rate para preguntas sobre performance y testing
- Ten ejemplos adicionales listos por si necesitas clarificar

POSIBLES PREGUNTAS Y RESPUESTAS:

Q: "Â¿Por quÃ© no usar siempre Enum Singleton si es el mÃ¡s seguro?"
A: "Porque no todos los casos necesitan esa robustez. Para casos simples, Bill Pugh es mÃ¡s claro y flexible. Enum es mejor para servicios crÃ­ticos donde la seguridad es paramount."

Q: "Â¿CÃ³mo se comporta el Singleton en aplicaciones distribuidas?"
A: "En microservicios, cada instancia de servicio tendrÃ­a su propio singleton. Para estado verdaderamente global, necesitarÃ­amos external stores como Redis o bases de datos."

Q: "Â¿QuÃ© pasa si necesito pasar parÃ¡metros al constructor?"
A: "Eso es una seÃ±al de que quizÃ¡s no deberÃ­a ser singleton. Considera usar Factory pattern o dependency injection con configuraciÃ³n externa."

===============================================================================
